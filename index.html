<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Interactive 3D world globe with 195+ countries. Explore geography, take quizzes, and learn about the world with this free educational WebGL map powered by Three.js.">
    <meta name="keywords" content="3D world map, interactive globe, geography quiz, world atlas, educational map, Three.js globe, WebGL earth, geography learning">
    <title>Interactive 3D World Globe Map | Free Geography Quiz & Educational Tool</title>
    <link rel="stylesheet" href="styles.css">
    <!-- Confetti Library -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
</head>
<body>
    <!-- SEO Content Overlay -->
    <div id="seo-content">
        <div id="seo-text-wrapper">
            <h1>Interactive 3D World Globe</h1>
            <p>Explore our interactive 3D globe featuring all 195 countries of the world. Click, drag, and zoom to discover geography in an immersive way.</p>

            <h2>Features</h2>
            <ul>
                <li>Interactive 3D visualization of all countries</li>
                <li>Geography quizzes to test your knowledge</li>
                <li>Country information including flags, population, and area</li>
                <li>Smooth rotation and zoom controls</li>
                <li>Educational tool for learning world geography</li>
            </ul>

            <p><strong>Wait for the globe to load, then click the start button below!</strong></p>
        </div>

        <!-- Loading Progress Bar and Start Button -->
        <div id="loading-progress-container">
            <div id="loading-progress-bar">
                <div id="loading-progress-fill"></div>
                <div id="loading-progress-text">Loading... 0%</div>
            </div>
            <button id="start-button" style="display: none;">Start Exploring</button>
        </div>
    </div>

    <div id="container">
        <button id="zoom-out-btn">üåç Zoom Out</button>
        <div id="loading">Loading world map data...</div>
        <button id="take-quiz-btn">Take Quiz</button>
        <button id="edit-mode-btn">Edit Labels</button>
        <button id="save-config-btn" style="display: none;">Save Config</button>
        <button id="fine-tune-btn" style="display: none;">Fine Tune</button>
        <button id="edit-colors-btn">Edit Colors</button>
        <button id="save-colors-btn" style="display: none;">Save Colors</button>

        <!-- Zoom Level Widget -->
        <div id="zoom-widget">
            <div id="zoom-label-top">Zoom</div>
            <div id="zoom-bar-container">
                <div id="zoom-bar-fill"></div>
            </div>
            <div id="zoom-value">2.5</div>
        </div>

        <div id="flag-container">
            <div id="flag-container-content">
                <div id="flag-info">
                    <div class="country-name"></div>
                    <div class="info-item"><span class="info-label">Population:</span> <span id="info-population"></span></div>
                    <div class="info-item"><span class="info-label">Area:</span> <span id="info-area"></span></div>
                    <div class="info-item"><span class="info-label">Language:</span> <span id="info-language"></span></div>
                </div>
            </div>
        </div>
        <div id="search-container">
            <div id="search-box">
                <span id="search-icon">üîç</span>
                <input type="text" id="country-search" placeholder="Search countries...">
            </div>
            <div id="search-results"></div>
        </div>
        <div id="controls">
            <div class="control-item">
                <strong>Controls:</strong>
            </div>
            <div class="control-item">
                ‚Ä¢ Drag to rotate
            </div>
            <div class="control-item">
                ‚Ä¢ Scroll to zoom
            </div>
            <div class="control-item" style="margin-top: 15px;">
                <strong>Inner Sphere Radius:</strong>
            </div>
            <div class="control-item">
                <span id="sphere-radius-value">1.014</span>
                <button id="sphere-radius-down" style="margin-left: 10px; padding: 2px 8px;">‚ñº</button>
                <button id="sphere-radius-up" style="padding: 2px 8px;">‚ñ≤</button>
            </div>
            <div class="control-item">
                <label for="sphere-toggle" style="width: auto;">
                    <input type="checkbox" id="sphere-toggle" checked style="width: auto; margin-right: 5px;">
                    Show Inner Sphere
                </label>
            </div>
        </div>
        <div id="quiz-container">
            <div id="quiz-header">Geography Quiz</div>
            <div id="quiz-score" style="display: none;">Score: <span id="quiz-score-value">0</span> / <span id="quiz-total-value">0</span></div>
            <div id="quiz-question" style="display: none;">Which country is highlighted?</div>
            <div id="quiz-flag-display" style="display: none;">
                <!-- Flag will be rendered here -->
            </div>
            <div id="quiz-options">
                <!-- Options will be dynamically inserted here -->
            </div>
            <div id="quiz-result"></div>
            <button id="quiz-start-btn">Start Quiz</button>
            <button id="quiz-next-btn" style="visibility: hidden;">Next Question</button>
        </div>

        <!-- Quiz Celebration Overlay -->
        <div id="quiz-celebration-overlay" style="display: none;">
            <div id="quiz-celebration-content">
                <h1 id="celebration-title">üéâ Congratulations! üéâ</h1>
                <p id="celebration-message">Quiz Complete!</p>
                <div id="celebration-score"></div>
                <button id="celebration-close-btn">Play Again</button>
            </div>
        </div>

        <!-- Quiz Mode Selector Modal -->
        <div id="quiz-mode-selector" style="display: none;">
            <div id="quiz-mode-overlay"></div>
            <div id="quiz-mode-content">
                <h2>Choose Quiz Mode</h2>
                <div id="quiz-mode-options">
                    <button class="quiz-mode-option" id="name-flag-quiz-btn">
                        <h3>Name the Flag</h3>
                        <p>Identify countries from their highlighted location and choose the correct name</p>
                    </button>
                    <button class="quiz-mode-option" id="identify-flag-quiz-btn">
                        <h3>Identify the Flag</h3>
                        <p>Look at the flag and choose which country it belongs to</p>
                    </button>
                    <button class="quiz-mode-option" id="find-country-quiz-btn">
                        <h3>Find the Country</h3>
                        <p>Click on the correct country when given its name - 10 questions in 45 seconds!</p>
                    </button>
                </div>
                <button id="quiz-mode-close">Cancel</button>
            </div>
        </div>

        <!-- Click Quiz UI -->
        <div id="click-quiz-container" style="display: none;">
            <div id="click-quiz-header">
                <div id="click-quiz-country-name"></div>
                <div id="click-quiz-info">
                    <span id="click-quiz-question-counter"></span>
                    <span id="click-quiz-score-display"></span>
                </div>
            </div>
            <div id="click-quiz-feedback"></div>
        </div>

        <!-- Click Quiz Timer Bar -->
        <div id="click-quiz-timer-bar-container" style="display: none;">
            <div id="click-quiz-timer-fill"></div>
        </div>

        <!-- Click Quiz Results Modal -->
        <div id="click-quiz-results" style="display: none;">
            <div id="click-quiz-results-overlay"></div>
            <div id="click-quiz-results-content">
                <h2>Quiz Complete!</h2>
                <div id="click-quiz-final-score"></div>
                <div id="click-quiz-final-time"></div>
                <button id="click-quiz-close-btn">Close</button>
            </div>
        </div>

        <!-- Label Editor Modal -->
        <div id="label-editor-modal" style="display: none;">
            <div id="label-editor-overlay"></div>
            <div id="label-editor-content">
                <h2 id="label-editor-title">Edit Label</h2>
                <div class="label-editor-section">
                    <label>Position Offset X:</label>
                    <input type="range" id="label-offset-x" min="-0.2" max="0.2" step="0.01" value="0">
                    <span id="label-offset-x-value">0.00</span>
                </div>
                <div class="label-editor-section">
                    <label>Position Offset Y:</label>
                    <input type="range" id="label-offset-y" min="-0.2" max="0.2" step="0.01" value="0">
                    <span id="label-offset-y-value">0.00</span>
                </div>
                <div class="label-editor-section">
                    <label>Position Offset Z:</label>
                    <input type="range" id="label-offset-z" min="-0.2" max="0.2" step="0.01" value="0">
                    <span id="label-offset-z-value">0.00</span>
                </div>
                <div class="label-editor-section">
                    <label>Scale:</label>
                    <input type="range" id="label-scale" min="0.1" max="3.0" step="0.1" value="1.0">
                    <span id="label-scale-value">1.0</span>
                </div>
                <div class="label-editor-buttons">
                    <button id="label-reset-btn">Reset to Default</button>
                    <button id="label-editor-close-btn">Close</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/perlin.js/1.0/perlin.js"></script>
    <script>
        // ===== DOM UTILITIES (inline for compatibility) =====
        class ElementCache {
            constructor() {
                this.cache = new Map();
            }
            get(id) {
                if (!this.cache.has(id)) {
                    const element = document.getElementById(id);
                    if (element) {
                        this.cache.set(id, element);
                    }
                    return element;
                }
                return this.cache.get(id);
            }
        }

        const elements = new ElementCache();

        function show(element) {
            if (element) element.style.display = 'block';
        }

        function hide(element) {
            if (element) element.style.display = 'none';
        }

        function showFlex(element) {
            if (element) element.style.display = 'flex';
        }

        function setText(element, text) {
            if (element) element.textContent = text;
        }

        function addClass(element, className) {
            if (element && className) element.classList.add(className);
        }

        function removeClass(element, className) {
            if (element && className) element.classList.remove(className);
        }

        function toggleClass(element, className) {
            if (element && className) element.classList.toggle(className);
        }

        // Perlin noise library (inline for self-containment)
        (function(global){var module=global.noise={};function Grad(x,y,z){this.x=x;this.y=y;this.z=z}Grad.prototype.dot2=function(x,y){return this.x*x+this.y*y};Grad.prototype.dot3=function(x,y,z){return this.x*x+this.y*y+this.z*z};var grad3=[new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)];var p=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];var perm=new Array(512);var gradP=new Array(512);module.seed=function(seed){if(seed>0&&seed<1){seed*=65536}seed=Math.floor(seed);if(seed<256){seed|=seed<<8}for(var i=0;i<256;i++){var v;if(i&1){v=p[i]^(seed&255)}else{v=p[i]^((seed>>8)&255)}perm[i]=perm[i+256]=v;gradP[i]=gradP[i+256]=grad3[v%12]}};module.seed(0);function fade(t){return t*t*t*(t*(t*6-15)+10)}function lerp(a,b,t){return(1-t)*a+t*b}module.perlin2=function(x,y){var X=Math.floor(x),Y=Math.floor(y);x=x-X;y=y-Y;X=X&255;Y=Y&255;var n00=gradP[X+perm[Y]].dot2(x,y);var n01=gradP[X+perm[Y+1]].dot2(x,y-1);var n10=gradP[X+1+perm[Y]].dot2(x-1,y);var n11=gradP[X+1+perm[Y+1]].dot2(x-1,y-1);var u=fade(x);return lerp(lerp(n00,n10,u),lerp(n01,n11,u),fade(y))}})(this);

        // Global variables
        let scene, camera, renderer, globe, countries = [];
        let mouse = new THREE.Vector2();
        let raycaster = new THREE.Raycaster();
        let selectedCountry = null;
        let controls;
        let baseSphere;
        let mouseDownPos = new THREE.Vector2();
        let isDragging = false;
        let initialCameraDistance; // Store initial camera distance for zoom out

        // SEO content visibility
        let seoContentHidden = false;

        // Quiz variables
        let countryCentroids = []; // Array of { name, centroid: Vector3, meshRef }
        let quizActive = false;
        let currentQuizMode = null; // 'name-flag', 'identify-flag', or 'find-country'
        let currentQuizQuestion = null; // { correctCountry, options: [country names] }
        let quizScore = 0;
        let quizQuestionsAnswered = 0;
        let usedQuizCountries = []; // Track countries already used in current quiz
        let quizAutoAdvanceTimer = null; // Timer for auto-advancing to next question

        // Click quiz variables
        let clickQuizActive = false;
        let clickQuizCountries = []; // Array of 10 country names for this quiz
        let clickQuizCurrentIndex = 0; // Current question (0-9)
        let clickQuizScore = 0; // Number of correct answers
        let clickQuizStartTime = 0; // Timestamp when quiz started
        let clickQuizTimeRemaining = 45000; // Milliseconds remaining (45 seconds)
        let clickQuizTimerInterval = null; // Interval ID for timer updates

        // Country labels
        let countryLabels = []; // Array of label meshes

        // Edit mode variables
        let editMode = false;
        let selectedLabel = null;
        let labelConfig = {}; // Stores custom positions and font sizes
        let labelDefaults = {}; // Stores original/default positions and scales
        let isDraggingLabel = false;
        let selectionHelper = null; // Visual indicator for selected label
        let lastTapTime = 0;
        let longPressTimer = null;
        let longPressTriggered = false;

        // Color edit mode variables
        let colorEditMode = false;
        let colorConfig = {}; // Stores custom country colors

        // Curated color palette (10 distinct colors in darker tones for lighting)
        const COLOR_PALETTE = [
            [0.2, 0.5, 0.25],   // Forest Green
            [0.45, 0.45, 0.15], // Olive/Yellow-Green
            [0.5, 0.35, 0.15],  // Orange/Rust
            [0.35, 0.2, 0.45],  // Purple/Violet
            [0.2, 0.45, 0.45],  // Teal/Cyan
            [0.4, 0.3, 0.2],    // Brown/Earth
            [0.5, 0.45, 0.2],   // Dark Yellow/Gold
            [0.45, 0.25, 0.35], // Magenta/Deep Pink
            [0.2, 0.25, 0.4],   // Navy/Dark Blue
            [0.4, 0.2, 0.25]    // Burgundy/Wine Red
        ];

        // Country size categories for label sizing and visibility
        const LARGE_COUNTRIES = new Set([
            'Russia', 'Canada', 'United States', 'China', 'Brazil', 'Australia',
            'India', 'Argentina', 'Kazakhstan', 'Algeria', 'Democratic Republic Of The Congo',
            'Saudi Arabia', 'Mexico', 'Indonesia', 'Libya', 'Iran', 'Mongolia',
            'Peru', 'Chad', 'Niger', 'Angola', 'Mali', 'South Africa', 'Colombia',
            'Ethiopia', 'Bolivia', 'Mauritania', 'Egypt', 'Tanzania', 'Nigeria',
            'Venezuela', 'Pakistan', 'Mozambique', 'Turkey', 'Chile', 'Zambia',
            'Myanmar', 'Afghanistan', 'Somalia', 'Central African Republic', 'Ukraine',
            'Madagascar', 'Botswana', 'Kenya', 'France', 'Yemen', 'Thailand',
            'Spain', 'Turkmenistan', 'Cameroon', 'Papua New Guinea', 'Sweden',
            'Uzbekistan', 'Morocco', 'Iraq', 'Paraguay', 'Zimbabwe'
        ]);

        const SMALL_COUNTRIES = new Set([
            'Singapore', 'Bahrain', 'Malta', 'Maldives', 'Barbados',
            'Saint Lucia', 'Antigua And Barbuda', 'Andorra', 'Seychelles',
            'Palau', 'Saint Vincent And The Grenadines', 'Grenada',
            'Saint Kitts And Nevis', 'Marshall Islands', 'Liechtenstein',
            'San Marino', 'Tuvalu', 'Nauru', 'Monaco', 'Vatican City',
            'Comoros', 'Mauritius', 'Sao Tome And Principe', 'Dominica',
            'Tonga', 'Kiribati', 'Micronesia', 'Cape Verde', 'Samoa'
        ]);

        // Country borders
        let countryBorders = []; // Array of border line segments

        // Flag animation variables
        let flagScene, flagCamera, flagRenderer;
        let flagMesh, flagOriginalPositions;
        let flagTime = 0;
        let currentHoveredCountry = null;

        // Search state
        let searchResultsCache = '';
        let selectedSearchCountry = null; // Track the country selected from search
        let currentSearchIndex = -1; // Track currently selected search result index

        // Auto-rotation state
        let autoRotateEnabled = false;
        let lastInteractionTime = Date.now();
        let idleTimeout = null;
        const IDLE_DELAY = 60000; // 1 minute

        // Country data: ISO code, population (millions), area (km¬≤), primary language
        const countryData = {
            'United States': { iso: 'us', pop: 331.9, area: '9.8M km¬≤', lang: 'English' },
            'Canada': { iso: 'ca', pop: 38.2, area: '9.9M km¬≤', lang: 'English, French' },
            'Mexico': { iso: 'mx', pop: 126.7, area: '1.9M km¬≤', lang: 'Spanish' },
            'Brazil': { iso: 'br', pop: 214.3, area: '8.5M km¬≤', lang: 'Portuguese' },
            'Argentina': { iso: 'ar', pop: 45.8, area: '2.8M km¬≤', lang: 'Spanish' },
            'Chile': { iso: 'cl', pop: 19.5, area: '756K km¬≤', lang: 'Spanish' },
            'Peru': { iso: 'pe', pop: 33.7, area: '1.3M km¬≤', lang: 'Spanish' },
            'Colombia': { iso: 'co', pop: 51.5, area: '1.1M km¬≤', lang: 'Spanish' },
            'Venezuela': { iso: 've', pop: 28.2, area: '916K km¬≤', lang: 'Spanish' },
            'United Kingdom': { iso: 'gb', pop: 67.3, area: '243K km¬≤', lang: 'English' },
            'France': { iso: 'fr', pop: 67.7, area: '643K km¬≤', lang: 'French' },
            'Germany': { iso: 'de', pop: 83.2, area: '357K km¬≤', lang: 'German' },
            'Italy': { iso: 'it', pop: 59.1, area: '301K km¬≤', lang: 'Italian' },
            'Spain': { iso: 'es', pop: 47.4, area: '506K km¬≤', lang: 'Spanish' },
            'Portugal': { iso: 'pt', pop: 10.3, area: '92K km¬≤', lang: 'Portuguese' },
            'Netherlands': { iso: 'nl', pop: 17.5, area: '42K km¬≤', lang: 'Dutch' },
            'Belgium': { iso: 'be', pop: 11.6, area: '31K km¬≤', lang: 'Dutch, French' },
            'Switzerland': { iso: 'ch', pop: 8.7, area: '41K km¬≤', lang: 'German, French' },
            'Austria': { iso: 'at', pop: 9.0, area: '84K km¬≤', lang: 'German' },
            'Poland': { iso: 'pl', pop: 38.0, area: '313K km¬≤', lang: 'Polish' },
            'Czech Republic': { iso: 'cz', pop: 10.5, area: '79K km¬≤', lang: 'Czech' },
            'Hungary': { iso: 'hu', pop: 9.7, area: '93K km¬≤', lang: 'Hungarian' },
            'Romania': { iso: 'ro', pop: 19.0, area: '238K km¬≤', lang: 'Romanian' },
            'Greece': { iso: 'gr', pop: 10.6, area: '132K km¬≤', lang: 'Greek' },
            'Turkey': { iso: 'tr', pop: 85.3, area: '784K km¬≤', lang: 'Turkish' },
            'Ukraine': { iso: 'ua', pop: 43.8, area: '604K km¬≤', lang: 'Ukrainian' },
            'Russia': { iso: 'ru', pop: 144.1, area: '17.1M km¬≤', lang: 'Russian' },
            'China': { iso: 'cn', pop: 1412.0, area: '9.6M km¬≤', lang: 'Mandarin' },
            'Japan': { iso: 'jp', pop: 125.7, area: '378K km¬≤', lang: 'Japanese' },
            'South Korea': { iso: 'kr', pop: 51.8, area: '100K km¬≤', lang: 'Korean' },
            'India': { iso: 'in', pop: 1408.0, area: '3.3M km¬≤', lang: 'Hindi, English' },
            'Pakistan': { iso: 'pk', pop: 229.5, area: '881K km¬≤', lang: 'Urdu' },
            'Bangladesh': { iso: 'bd', pop: 169.4, area: '148K km¬≤', lang: 'Bengali' },
            'Indonesia': { iso: 'id', pop: 275.5, area: '1.9M km¬≤', lang: 'Indonesian' },
            'Thailand': { iso: 'th', pop: 70.0, area: '513K km¬≤', lang: 'Thai' },
            'Vietnam': { iso: 'vn', pop: 98.2, area: '331K km¬≤', lang: 'Vietnamese' },
            'Philippines': { iso: 'ph', pop: 113.9, area: '300K km¬≤', lang: 'Filipino' },
            'Malaysia': { iso: 'my', pop: 33.2, area: '330K km¬≤', lang: 'Malay' },
            'Singapore': { iso: 'sg', pop: 5.9, area: '728 km¬≤', lang: 'English' },
            'Australia': { iso: 'au', pop: 25.9, area: '7.7M km¬≤', lang: 'English' },
            'New Zealand': { iso: 'nz', pop: 5.1, area: '268K km¬≤', lang: 'English' },
            'Egypt': { iso: 'eg', pop: 106.2, area: '1.0M km¬≤', lang: 'Arabic' },
            'South Africa': { iso: 'za', pop: 60.6, area: '1.2M km¬≤', lang: 'English, Afrikaans' },
            'Nigeria': { iso: 'ng', pop: 216.7, area: '924K km¬≤', lang: 'English' },
            'Kenya': { iso: 'ke', pop: 54.0, area: '580K km¬≤', lang: 'Swahili' },
            'Ethiopia': { iso: 'et', pop: 120.8, area: '1.1M km¬≤', lang: 'Amharic' },
            'Saudi Arabia': { iso: 'sa', pop: 35.9, area: '2.1M km¬≤', lang: 'Arabic' },
            'Iran': { iso: 'ir', pop: 87.9, area: '1.6M km¬≤', lang: 'Persian' },
            'Iraq': { iso: 'iq', pop: 42.2, area: '438K km¬≤', lang: 'Arabic' },
            'Israel': { iso: 'il', pop: 9.4, area: '22K km¬≤', lang: 'Hebrew' },
            'Norway': { iso: 'no', pop: 5.5, area: '385K km¬≤', lang: 'Norwegian' },
            'Sweden': { iso: 'se', pop: 10.4, area: '447K km¬≤', lang: 'Swedish' },
            'Finland': { iso: 'fi', pop: 5.5, area: '338K km¬≤', lang: 'Finnish' },
            'Denmark': { iso: 'dk', pop: 5.9, area: '43K km¬≤', lang: 'Danish' },
            'Ireland': { iso: 'ie', pop: 5.0, area: '70K km¬≤', lang: 'English' },
            'Iceland': { iso: 'is', pop: 0.4, area: '103K km¬≤', lang: 'Icelandic' },
            'Afghanistan': { iso: 'af', pop: 43.0, area: '653K km¬≤', lang: 'Pashto, Dari' },
            'Albania': { iso: 'al', pop: 2.4, area: '29K km¬≤', lang: 'Albanian' },
            'Algeria': { iso: 'dz', pop: 47.0, area: '2.4M km¬≤', lang: 'Arabic, Berber' },
            'Angola': { iso: 'ao', pop: 39.0, area: '1.2M km¬≤', lang: 'Portuguese' },
            'Armenia': { iso: 'am', pop: 3.1, area: '30K km¬≤', lang: 'Armenian' },
            'Azerbaijan': { iso: 'az', pop: 10.4, area: '87K km¬≤', lang: 'Azerbaijani' },
            'Bahrain': { iso: 'bh', pop: 1.5, area: '787 km¬≤', lang: 'Arabic' },
            'Belarus': { iso: 'by', pop: 9.1, area: '208K km¬≤', lang: 'Belarusian, Russian' },
            'Belize': { iso: 'bz', pop: 0.4, area: '23K km¬≤', lang: 'English' },
            'Benin': { iso: 'bj', pop: 13.0, area: '115K km¬≤', lang: 'French' },
            'Bhutan': { iso: 'bt', pop: 0.7, area: '38K km¬≤', lang: 'Dzongkha' },
            'Bolivia': { iso: 'bo', pop: 11.4, area: '1.1M km¬≤', lang: 'Spanish' },
            'Bosnia And Herzegovina': { iso: 'ba', pop: 2.9, area: '51K km¬≤', lang: 'Bosnian, Croatian, Serbian' },
            'Botswana': { iso: 'bw', pop: 2.4, area: '582K km¬≤', lang: 'English, Tswana' },
            'Brunei': { iso: 'bn', pop: 0.5, area: '5.8K km¬≤', lang: 'Malay' },
            'Bulgaria': { iso: 'bg', pop: 6.5, area: '111K km¬≤', lang: 'Bulgarian' },
            'Burkina Faso': { iso: 'bf', pop: 22.5, area: '274K km¬≤', lang: 'French' },
            'Burundi': { iso: 'bi', pop: 14.2, area: '28K km¬≤', lang: 'Kirundi, French, English' },
            'Cambodia': { iso: 'kh', pop: 17.6, area: '181K km¬≤', lang: 'Khmer' },
            'Cameroon': { iso: 'cm', pop: 31.0, area: '475K km¬≤', lang: 'English, French' },
            'Cape Verde': { iso: 'cv', pop: 0.6, area: '4K km¬≤', lang: 'Portuguese' },
            'Central African Republic': { iso: 'cf', pop: 5.4, area: '623K km¬≤', lang: 'French, Sango' },
            'Chad': { iso: 'td', pop: 19.1, area: '1.3M km¬≤', lang: 'Arabic, French' },
            'Comoros': { iso: 'km', pop: 0.9, area: '2K km¬≤', lang: 'Comorian, French, Arabic' },
            'Congo': { iso: 'cg', pop: 6.2, area: '342K km¬≤', lang: 'French' },
            'Costa Rica': { iso: 'cr', pop: 5.0, area: '51K km¬≤', lang: 'Spanish' },
            'Croatia': { iso: 'hr', pop: 3.9, area: '57K km¬≤', lang: 'Croatian' },
            'Cuba': { iso: 'cu', pop: 11.0, area: '111K km¬≤', lang: 'Spanish' },
            'Cyprus': { iso: 'cy', pop: 0.9, area: '9.3K km¬≤', lang: 'Greek, Turkish' },
            'Dem Rep Of Congo': { iso: 'cd', pop: 112.0, area: '2.3M km¬≤', lang: 'French' },
            'Djibouti': { iso: 'dj', pop: 1.1, area: '23K km¬≤', lang: 'Arabic, French' },
            'Dominican Republic': { iso: 'do', pop: 11.4, area: '49K km¬≤', lang: 'Spanish' },
            'Ecuador': { iso: 'ec', pop: 17.5, area: '284K km¬≤', lang: 'Spanish' },
            'Equatorial Guinea': { iso: 'gq', pop: 1.8, area: '28K km¬≤', lang: 'Spanish, French, Portuguese' },
            'Eritrea': { iso: 'er', pop: 5.0, area: '120K km¬≤', lang: 'Tigrinya' },
            'Estonia': { iso: 'ee', pop: 1.4, area: '45K km¬≤', lang: 'Estonian' },
            'Fiji': { iso: 'fj', pop: 0.9, area: '18K km¬≤', lang: 'Fijian, English, Fiji Hindi' },
            'French Guiana': { iso: 'gf', pop: 0.3, area: '84K km¬≤', lang: 'French' },
            'Gabon': { iso: 'ga', pop: 2.3, area: '268K km¬≤', lang: 'French' },
            'Gambia': { iso: 'gm', pop: 2.4, area: '11K km¬≤', lang: 'English' },
            'Georgia': { iso: 'ge', pop: 3.9, area: '70K km¬≤', lang: 'Georgian' },
            'Ghana': { iso: 'gh', pop: 35.0, area: '240K km¬≤', lang: 'English' },
            'Guatemala': { iso: 'gt', pop: 18.0, area: '109K km¬≤', lang: 'Spanish' },
            'Guinea': { iso: 'gn', pop: 14.0, area: '246K km¬≤', lang: 'French' },
            'Guinea Bissau': { iso: 'gw', pop: 2.1, area: '36K km¬≤', lang: 'Portuguese' },
            'Guyana': { iso: 'gy', pop: 0.7, area: '215K km¬≤', lang: 'English' },
            'Haiti': { iso: 'ht', pop: 11.5, area: '28K km¬≤', lang: 'Haitian Creole, French' },
            'Honduras': { iso: 'hn', pop: 9.6, area: '112K km¬≤', lang: 'Spanish' },
            'Hong Kong': { iso: 'hk', pop: 7.5, area: '1.1K km¬≤', lang: 'Chinese, English' },
            'Ivory Coast': { iso: 'ci', pop: 31.5, area: '322K km¬≤', lang: 'French' },
            'Jamaica': { iso: 'jm', pop: 2.8, area: '11K km¬≤', lang: 'English' },
            'Jordan': { iso: 'jo', pop: 11.5, area: '89K km¬≤', lang: 'Arabic' },
            'Kazakhstan': { iso: 'kz', pop: 20.3, area: '2.7M km¬≤', lang: 'Kazakh, Russian' },
            'Kiribati': { iso: 'ki', pop: 0.1, area: '811 km¬≤', lang: 'English, Gilbertese' },
            'Kosovo': { iso: 'xk', pop: 1.6, area: '11K km¬≤', lang: 'Albanian, Serbian' },
            'Kuwait': { iso: 'kw', pop: 4.8, area: '18K km¬≤', lang: 'Arabic' },
            'Kyrgyzstan': { iso: 'kg', pop: 7.3, area: '200K km¬≤', lang: 'Kyrgyz, Russian' },
            'Laos': { iso: 'la', pop: 8.0, area: '237K km¬≤', lang: 'Lao' },
            'Latvia': { iso: 'lv', pop: 1.8, area: '65K km¬≤', lang: 'Latvian' },
            'Lebanon': { iso: 'lb', pop: 5.4, area: '10K km¬≤', lang: 'Arabic' },
            'Lesotho': { iso: 'ls', pop: 2.2, area: '30K km¬≤', lang: 'Sesotho, English' },
            'Liberia': { iso: 'lr', pop: 5.4, area: '111K km¬≤', lang: 'English' },
            'Libya': { iso: 'ly', pop: 7.4, area: '1.8M km¬≤', lang: 'Arabic' },
            'Lithuania': { iso: 'lt', pop: 2.9, area: '65K km¬≤', lang: 'Lithuanian' },
            'Luxembourg': { iso: 'lu', pop: 0.7, area: '2.6K km¬≤', lang: 'Luxembourgish, French, German' },
            'Macau': { iso: 'mo', pop: 0.7, area: '119 km¬≤', lang: 'Chinese, Portuguese' },
            'Macedonia': { iso: 'mk', pop: 1.8, area: '25K km¬≤', lang: 'Macedonian, Albanian' },
            'Madagascar': { iso: 'mg', pop: 32.0, area: '593K km¬≤', lang: 'Malagasy, French' },
            'Malawi': { iso: 'mw', pop: 22.2, area: '118K km¬≤', lang: 'English' },
            'Maldives': { iso: 'mv', pop: 0.5, area: '298 km¬≤', lang: 'Dhivehi' },
            'Mali': { iso: 'ml', pop: 22.0, area: '1.2M km¬≤', lang: 'French' },
            'Malta': { iso: 'mt', pop: 0.5, area: '316 km¬≤', lang: 'Maltese, English' },
            'Marshall Islands': { iso: 'mh', pop: 0.04, area: '181 km¬≤', lang: 'Marshallese, English' },
            'Mauritania': { iso: 'mr', pop: 4.3, area: '1.0M km¬≤', lang: 'Arabic' },
            'Mauritius': { iso: 'mu', pop: 1.2, area: '2K km¬≤', lang: 'English, French' },
            'Micronesia': { iso: 'fm', pop: 0.1, area: '702 km¬≤', lang: 'English' },
            'Moldova': { iso: 'md', pop: 2.4, area: '34K km¬≤', lang: 'Romanian' },
            'Mongolia': { iso: 'mn', pop: 3.5, area: '1.6M km¬≤', lang: 'Mongolian' },
            'Montenegro': { iso: 'me', pop: 0.6, area: '14K km¬≤', lang: 'Montenegrin' },
            'Morocco': { iso: 'ma', pop: 37.5, area: '447K km¬≤', lang: 'Arabic, Berber' },
            'Mozambique': { iso: 'mz', pop: 34.9, area: '802K km¬≤', lang: 'Portuguese' },
            'Myanmar': { iso: 'mm', pop: 55.8, area: '677K km¬≤', lang: 'Burmese' },
            'Namibia': { iso: 'na', pop: 3.1, area: '826K km¬≤', lang: 'English' },
            'Nauru': { iso: 'nr', pop: 0.01, area: '21 km¬≤', lang: 'Nauruan, English' },
            'Nepal': { iso: 'np', pop: 31.1, area: '148K km¬≤', lang: 'Nepali' },
            'Nicaragua': { iso: 'ni', pop: 6.7, area: '130K km¬≤', lang: 'Spanish' },
            'Niger': { iso: 'ne', pop: 25.0, area: '1.3M km¬≤', lang: 'Hausa, French' },
            'North Korea': { iso: 'kp', pop: 26.3, area: '121K km¬≤', lang: 'Korean' },
            'Oman': { iso: 'om', pop: 5.5, area: '310K km¬≤', lang: 'Arabic' },
            'Palau': { iso: 'pw', pop: 0.02, area: '459 km¬≤', lang: 'Palauan, English' },
            'Panama': { iso: 'pa', pop: 4.3, area: '75K km¬≤', lang: 'Spanish' },
            'Papua New Guinea': { iso: 'pg', pop: 11.8, area: '463K km¬≤', lang: 'English, Tok Pisin, Hiri Motu' },
            'Paraguay': { iso: 'py', pop: 6.4, area: '407K km¬≤', lang: 'Spanish, Guarani' },
            'Puerto Rico': { iso: 'pr', pop: 3.2, area: '14K km¬≤', lang: 'Spanish, English' },
            'Qatar': { iso: 'qa', pop: 3.2, area: '12K km¬≤', lang: 'Arabic' },
            'Rwanda': { iso: 'rw', pop: 13.6, area: '27K km¬≤', lang: 'Kinyarwanda, English, French, Swahili' },
            'Samoa': { iso: 'ws', pop: 0.2, area: '2.8K km¬≤', lang: 'Samoan, English' },
            'Sao Tome And Principe': { iso: 'st', pop: 0.2, area: '964 km¬≤', lang: 'Portuguese' },
            'Senegal': { iso: 'sn', pop: 18.9, area: '197K km¬≤', lang: 'French' },
            'Serbia': { iso: 'rs', pop: 6.6, area: '88K km¬≤', lang: 'Serbian' },
            'Seychelles': { iso: 'sc', pop: 0.1, area: '457 km¬≤', lang: 'Seychellois Creole, English, French' },
            'Sierra Leone': { iso: 'sl', pop: 8.5, area: '73K km¬≤', lang: 'English' },
            'Slovakia': { iso: 'sk', pop: 5.4, area: '49K km¬≤', lang: 'Slovak' },
            'Slovenia': { iso: 'si', pop: 2.1, area: '20K km¬≤', lang: 'Slovene' },
            'Solomon Islands': { iso: 'sb', pop: 0.7, area: '29K km¬≤', lang: 'English' },
            'Somalia': { iso: 'so', pop: 18.1, area: '638K km¬≤', lang: 'Somali, Arabic' },
            'Sri Lanka': { iso: 'lk', pop: 21.8, area: '67K km¬≤', lang: 'Sinhala, Tamil' },
            'Sudan': { iso: 'sd', pop: 50.0, area: '1.9M km¬≤', lang: 'Arabic, English' },
            'Suriname': { iso: 'sr', pop: 0.6, area: '166K km¬≤', lang: 'Dutch' },
            'Swaziland': { iso: 'sz', pop: 1.2, area: '17K km¬≤', lang: 'Swazi, English' },
            'Syria': { iso: 'sy', pop: 25.3, area: '185K km¬≤', lang: 'Arabic' },
            'Taiwan': { iso: 'tw', pop: 23.9, area: '36K km¬≤', lang: 'Mandarin' },
            'Tajikistan': { iso: 'tj', pop: 10.7, area: '143K km¬≤', lang: 'Tajik, Russian' },
            'Tanzania': { iso: 'tz', pop: 67.5, area: '947K km¬≤', lang: 'Swahili, English' },
            'Timor Leste': { iso: 'tl', pop: 1.3, area: '15K km¬≤', lang: 'Portuguese, Tetum' },
            'Togo': { iso: 'tg', pop: 8.6, area: '57K km¬≤', lang: 'French' },
            'Tonga': { iso: 'to', pop: 0.1, area: '748 km¬≤', lang: 'Tongan, English' },
            'Trinidad And Tobago': { iso: 'tt', pop: 1.5, area: '5.1K km¬≤', lang: 'English' },
            'Tunisia': { iso: 'tn', pop: 12.1, area: '164K km¬≤', lang: 'Arabic' },
            'Turkmenistan': { iso: 'tm', pop: 7.1, area: '491K km¬≤', lang: 'Turkmen' },
            'Tuvalu': { iso: 'tv', pop: 0.01, area: '25 km¬≤', lang: 'Tuvaluan, English' },
            'Uganda': { iso: 'ug', pop: 49.3, area: '241K km¬≤', lang: 'English, Swahili' },
            'United Arab Emirates': { iso: 'ae', pop: 11.0, area: '84K km¬≤', lang: 'Arabic' },
            'Uruguay': { iso: 'uy', pop: 3.5, area: '176K km¬≤', lang: 'Spanish' },
            'Uzbekistan': { iso: 'uz', pop: 37.6, area: '449K km¬≤', lang: 'Uzbek' },
            'Vanuatu': { iso: 'vu', pop: 0.3, area: '12K km¬≤', lang: 'Bislama, English, French' },
            'Yemen': { iso: 'ye', pop: 32.7, area: '456K km¬≤', lang: 'Arabic' },
            'Zambia': { iso: 'zm', pop: 20.2, area: '753K km¬≤', lang: 'English' },
            'Zimbabwe': { iso: 'zw', pop: 16.6, area: '391K km¬≤', lang: 'English, Shona' }
        };

        // Legacy ISO mapping for backward compatibility
        const countryToISO = {
            'United States': 'us', 'Canada': 'ca', 'Mexico': 'mx', 'Brazil': 'br', 'Argentina': 'ar',
            'Chile': 'cl', 'Peru': 'pe', 'Colombia': 'co', 'Venezuela': 've', 'Ecuador': 'ec',
            'United Kingdom': 'gb', 'France': 'fr', 'Germany': 'de', 'Italy': 'it', 'Spain': 'es',
            'Portugal': 'pt', 'Netherlands': 'nl', 'Belgium': 'be', 'Switzerland': 'ch', 'Austria': 'at',
            'Poland': 'pl', 'Czech Republic': 'cz', 'Hungary': 'hu', 'Romania': 'ro', 'Bulgaria': 'bg',
            'Greece': 'gr', 'Turkey': 'tr', 'Ukraine': 'ua', 'Russia': 'ru', 'Belarus': 'by',
            'China': 'cn', 'Japan': 'jp', 'South Korea': 'kr', 'North Korea': 'kp', 'India': 'in',
            'Pakistan': 'pk', 'Bangladesh': 'bd', 'Indonesia': 'id', 'Thailand': 'th', 'Vietnam': 'vn',
            'Philippines': 'ph', 'Malaysia': 'my', 'Singapore': 'sg', 'Myanmar': 'mm', 'Cambodia': 'kh',
            'Australia': 'au', 'New Zealand': 'nz', 'Papua New Guinea': 'pg', 'Fiji': 'fj',
            'Egypt': 'eg', 'South Africa': 'za', 'Nigeria': 'ng', 'Kenya': 'ke', 'Ethiopia': 'et',
            'Morocco': 'ma', 'Algeria': 'dz', 'Tunisia': 'tn', 'Libya': 'ly', 'Sudan': 'sd',
            'Saudi Arabia': 'sa', 'Iran': 'ir', 'Iraq': 'iq', 'Israel': 'il', 'Jordan': 'jo',
            'Lebanon': 'lb', 'Syria': 'sy', 'Yemen': 'ye', 'Oman': 'om', 'Kuwait': 'kw',
            'United Arab Emirates': 'ae', 'Qatar': 'qa', 'Bahrain': 'bh',
            'Norway': 'no', 'Sweden': 'se', 'Finland': 'fi', 'Denmark': 'dk', 'Iceland': 'is',
            'Ireland': 'ie', 'Latvia': 'lv', 'Lithuania': 'lt', 'Estonia': 'ee',
            'Slovakia': 'sk', 'Slovenia': 'si', 'Croatia': 'hr', 'Serbia': 'rs', 'Bosnia And Herzegovina': 'ba',
            'Montenegro': 'me', 'Albania': 'al', 'Macedonia': 'mk', 'Kosovo': 'xk',
            'Afghanistan': 'af', 'Kazakhstan': 'kz', 'Uzbekistan': 'uz', 'Turkmenistan': 'tm',
            'Kyrgyzstan': 'kg', 'Tajikistan': 'tj', 'Mongolia': 'mn', 'Nepal': 'np', 'Bhutan': 'bt',
            'Sri Lanka': 'lk', 'Laos': 'la', 'Taiwan': 'tw', 'Hong Kong': 'hk', 'Macau': 'mo',
            'Angola': 'ao', 'Mozambique': 'mz', 'Tanzania': 'tz', 'Uganda': 'ug', 'Rwanda': 'rw',
            'Burundi': 'bi', 'Zimbabwe': 'zw', 'Zambia': 'zm', 'Malawi': 'mw', 'Botswana': 'bw',
            'Namibia': 'na', 'Ghana': 'gh', 'Ivory Coast': 'ci', 'Senegal': 'sn', 'Mali': 'ml',
            'Niger': 'ne', 'Chad': 'td', 'Somalia': 'so', 'Congo': 'cg', 'Gabon': 'ga',
            'Cameroon': 'cm', 'Madagascar': 'mg', 'Mauritania': 'mr', 'Benin': 'bj', 'Togo': 'tg',
            'Uruguay': 'uy', 'Paraguay': 'py', 'Bolivia': 'bo', 'Guyana': 'gy', 'Suriname': 'sr',
            'French Guiana': 'gf', 'Belize': 'bz', 'Guatemala': 'gt', 'Honduras': 'hn', 'Nicaragua': 'ni',
            'Costa Rica': 'cr', 'Panama': 'pa', 'Cuba': 'cu', 'Jamaica': 'jm', 'Haiti': 'ht',
            'Dominican Republic': 'do', 'Puerto Rico': 'pr', 'Trinidad And Tobago': 'tt',
            'Luxembourg': 'lu', 'Malta': 'mt', 'Cyprus': 'cy', 'Moldova': 'md', 'Armenia': 'am',
            'Georgia': 'ge', 'Azerbaijan': 'az', 'Eritrea': 'er', 'Djibouti': 'dj',
            'Central African Republic': 'cf', 'Guinea': 'gn', 'Sierra Leone': 'sl', 'Liberia': 'lr',
            'Burkina Faso': 'bf', 'Lesotho': 'ls', 'Swaziland': 'sz', 'Mauritius': 'mu',
            'Seychelles': 'sc', 'Comoros': 'km', 'Cape Verde': 'cv', 'Sao Tome And Principe': 'st',
            'Equatorial Guinea': 'gq', 'Gambia': 'gm', 'Guinea Bissau': 'gw', 'Dem Rep Of Congo': 'cd',
            'Timor Leste': 'tl', 'Brunei': 'bn', 'Maldives': 'mv', 'Solomon Islands': 'sb',
            'Vanuatu': 'vu', 'Samoa': 'ws', 'Kiribati': 'ki', 'Tonga': 'to', 'Micronesia': 'fm',
            'Palau': 'pw', 'Marshall Islands': 'mh', 'Nauru': 'nr', 'Tuvalu': 'tv'
        };

        // Hide SEO content when start button is clicked
        function hideSeoContent() {
            if (!seoContentHidden) {
                seoContentHidden = true;
                const seoContent = elements.get('seo-content');
                if (seoContent) {
                    addClass(seoContent, 'hidden');
                    // Remove after animation completes
                    setTimeout(() => {
                        hide(seoContent);
                    }, 500);
                }
            }
        }

        // Add click event listener to start button (will be available after loading completes)
        // Using event delegation to ensure button is available
        document.addEventListener('click', function(event) {
            if (event.target && event.target.id === 'start-button') {
                hideSeoContent();
            }
        });

        // Initialize the scene
        function init() {
            // Initialize flag renderer (separate mini scene)
            initFlagRenderer();

            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x001122);

            // Create camera with adaptive positioning
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            // Calculate initial camera distance based on device
            const aspectRatio = window.innerWidth / window.innerHeight;
            const fov = 75 * Math.PI / 180; // Convert to radians
            const isMobile = window.innerWidth <= 768;

            // Calculate distance needed for globe to occupy viewport
            let cameraDistance;
            let targetPercentage = isMobile ? 0.85 : 0.70; // 85% on mobile, 70% on desktop

            if (aspectRatio >= 1) {
                // Width >= Height, so height is the limiting dimension
                cameraDistance = (1 / Math.tan(fov / 2)) / targetPercentage;
            } else {
                // Height > Width, so width is the limiting dimension
                const horizontalFov = 2 * Math.atan(Math.tan(fov / 2) * aspectRatio);
                cameraDistance = (1 / Math.tan(horizontalFov / 2)) / targetPercentage;
            }

            // Store initial camera distance for zoom out button
            initialCameraDistance = cameraDistance;

            // Center globe vertically on all screen sizes
            const verticalOffset = 0;
            camera.position.set(0, verticalOffset, cameraDistance);

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.domElement.id = 'globe-canvas';
            elements.get('container').appendChild(renderer.domElement);

            // Add lights
            setupLights();

            // Create globe container
            globe = new THREE.Group();
            scene.add(globe);

            // Create base sphere (inner blocker)
            // Radius is 1.014 (just below countries at 1.02) to block artifacts from inside
            const sphereGeometry = new THREE.SphereGeometry(1.014, 64, 64);
            const sphereMaterial = new THREE.MeshPhongMaterial({
                color: 0x001a33, // Dark blue ocean color
                transparent: false,
                opacity: 1.0,
                side: THREE.BackSide, // Render inside surface to block artifacts
                depthWrite: true,
                shininess: 30, // Moderate reflectivity
                specular: 0x222222 // Subtle highlights
            });
            baseSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            globe.add(baseSphere);

            // Add latitude and longitude lines
            addLatLongLines();

            // Load world data and create countries
            loadWorldData();

            // Setup orbit controls
            setupControls();

            // Add event listeners
            setupEventListeners();

            // Start animation loop
            animate();
        }

        function setupControls() {
            // Create OrbitControls
            controls = new THREE.OrbitControls(camera, renderer.domElement);

            // Enable damping for smooth movement
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Keep earth centered - no panning
            controls.enablePan = false;

            // Set zoom limits (distance from center)
            controls.minDistance = 1.13;  // Closest zoom (optimal close view)
            controls.maxDistance = 10;   // Farthest zoom

            // No restrictions on vertical rotation - user can tilt freely
            // (Polar angle limits removed to allow full sphere rotation)

            // Enable rotation
            controls.enableRotate = true;
            controls.rotateSpeed = 0.5;

            // Auto-rotate disabled initially, will enable after 1 minute of inactivity
            controls.autoRotate = false;
            controls.autoRotateSpeed = 1.0; // 2x rotation speed

            // Set target to center of scene (earth's center)
            controls.target.set(0, 0, 0);
            controls.update();

            // Start idle timer to enable auto-rotation after initial delay
            // TEMPORARILY DISABLED
            // idleTimeout = setTimeout(() => {
            //     resumeAutoRotation();
            // }, IDLE_DELAY);
        }

        // Stop auto-rotation and start idle timer
        function stopAutoRotation() {
            autoRotateEnabled = false;
            controls.autoRotate = false;

            // Clear any existing idle timeout
            if (idleTimeout) {
                clearTimeout(idleTimeout);
            }

            // Start idle timer - resume rotation after idle period
            // TEMPORARILY DISABLED
            // idleTimeout = setTimeout(() => {
            //     resumeAutoRotation();
            // }, IDLE_DELAY);
        }

        // Resume auto-rotation (only if not in quiz mode)
        function resumeAutoRotation() {
            if (!quizActive) {
                autoRotateEnabled = true;
                controls.autoRotate = true;
                // No tilt animation - maintain current camera angle

                // Clear the selected country highlight
                selectedSearchCountry = null;

                // Reset all countries to normal state
                countries.forEach(country => {
                    country.material.vertexColors = true;
                    country.material.color.setHex(0xffffff);
                    country.material.needsUpdate = true;
                });

                // Hide the flag container
                hideWavingFlag();
            }
        }

        // Reset idle timer on user interaction
        function resetIdleTimer() {
            lastInteractionTime = Date.now();

            // Only stop rotation if it's currently enabled
            if (autoRotateEnabled) {
                stopAutoRotation();
            }
        }

        function setupLights() {
            // Ambient light - provides overall base illumination
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            // Directional light behind camera (will be updated in animate loop)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(0, 0, 10); // Behind camera
            scene.add(directionalLight);

            // Additional point lights for better coverage
            const pointLight1 = new THREE.PointLight(0xffffff, 0.5);
            pointLight1.position.set(5, 5, 5);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xffffff, 0.5);
            pointLight2.position.set(-5, -5, 5);
            scene.add(pointLight2);

            // Store reference for updating position with camera
            scene.userData.cameraLight = directionalLight;
        }

        // Helper function to update loading progress
        let currentProgress = 0;
        let progressAnimationFrame = null;

        function updateLoadingProgress(percent, message = null, animated = false) {
            const progressFill = elements.get('loading-progress-fill');
            const progressText = elements.get('loading-progress-text');
            const loadingDiv = elements.get('loading');

            if (animated) {
                // Cancel any ongoing animation
                if (progressAnimationFrame) {
                    cancelAnimationFrame(progressAnimationFrame);
                }

                const startProgress = currentProgress;
                const targetProgress = percent;
                const duration = 600; // 600ms for smooth animation
                const startTime = Date.now();

                function animate() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // Ease out cubic for smooth deceleration
                    const easeProgress = 1 - Math.pow(1 - progress, 3);
                    const newProgress = startProgress + (targetProgress - startProgress) * easeProgress;

                    currentProgress = newProgress;

                    if (progressFill) {
                        progressFill.style.width = newProgress + '%';
                    }
                    if (progressText && message) {
                        setText(progressText, message);
                    }

                    if (progress < 1) {
                        progressAnimationFrame = requestAnimationFrame(animate);
                    } else {
                        progressAnimationFrame = null;
                    }
                }

                if (message && progressText) {
                    setText(progressText, message);
                }

                animate();
            } else {
                // Instant update (for download progress)
                currentProgress = percent;

                if (progressFill) {
                    progressFill.style.width = percent + '%';
                }
                if (progressText) {
                    const displayMessage = message || `Loading... ${percent}%`;
                    setText(progressText, displayMessage);
                }
                if (loadingDiv && message) {
                    setText(loadingDiv, message);
                }
            }
        }

        async function loadWorldData() {
            try {
                console.log('Loading world globe...');

                // Create DRACOLoader for decompressing the mesh
                const dracoLoader = new THREE.DRACOLoader();
                dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
                dracoLoader.setDecoderConfig({ type: 'js' });

                // Create GLTFLoader and attach DRACOLoader
                const loader = new THREE.GLTFLoader();
                loader.setDRACOLoader(dracoLoader);

                // Load the pre-built globe GLB file
                loader.load(
                    'assets/world.glb',
                    async function (gltf) {
                        console.log('GLB loaded successfully');
                        updateLoadingProgress(70, 'Processing countries...', true);

                        // Add all meshes from the GLB to the globe
                        gltf.scene.traverse((child) => {
                            if (child.isMesh) {
                                // Store reference for raycasting and interaction
                                child.userData.isCountry = true;

                                // Get the vertex color from the geometry (if available)
                                const hasVertexColors = child.geometry.attributes.color !== undefined;

                                // Set material to use vertex colors with Phong material for smooth lighting
                                if (hasVertexColors) {
                                    child.material = new THREE.MeshPhongMaterial({
                                        vertexColors: true,
                                        transparent: false,
                                        side: THREE.FrontSide,
                                        flatShading: false,
                                        shininess: 30
                                    });
                                } else {
                                    child.material = new THREE.MeshPhongMaterial({
                                        color: 0x4FC3F7,
                                        transparent: false,
                                        side: THREE.FrontSide,
                                        flatShading: false,
                                        shininess: 30
                                    });
                                }

                                // Extract country name from mesh name
                                // Remove the trailing number (e.g., "_0", "_1") and convert to title case
                                const countryName = child.name.replace(/_\d+$/, ''); // Remove trailing _number
                                const formattedName = countryName
                                    .replace(/_/g, ' ') // Replace underscores with spaces
                                    .split(' ')
                                    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                                    .join(' ');
                                child.userData.name = formattedName;

                                countries.push(child);
                            }
                        });

                        await new Promise(resolve => setTimeout(resolve, 300));
                        updateLoadingProgress(78, 'Building globe...', true);

                        // Add the entire scene to the globe
                        globe.add(gltf.scene);

                        console.log(`Loaded ${countries.length} country meshes`);

                        await new Promise(resolve => setTimeout(resolve, 300));
                        updateLoadingProgress(85, 'Calculating positions...', true);

                        // Build country centroids cache for quiz
                        buildCountryCentroidsCache();

                        await new Promise(resolve => setTimeout(resolve, 300));
                        updateLoadingProgress(90, 'Creating labels...', true);

                        // Create country labels
                        createCountryLabels();

                        await new Promise(resolve => setTimeout(resolve, 300));
                        updateLoadingProgress(95, 'Loading configuration...', true);

                        // Load saved label configuration if available
                        loadLabelConfig();

                        // Load saved color configuration if available
                        loadColorConfig();

                        // Create country borders
                        // createCountryBorders(); // Disabled for performance

                        await new Promise(resolve => setTimeout(resolve, 300));
                        updateLoadingProgress(100, 'Complete!', true);

                        await new Promise(resolve => setTimeout(resolve, 400));
                        hideLoading();
                    },
                    function (xhr) {
                        // Progress callback - scale download to 0-70% of total progress
                        const downloadPercent = (xhr.loaded / xhr.total * 100).toFixed(0);
                        const scaledPercent = Math.floor(downloadPercent * 0.7);
                        console.log(`Downloading: ${downloadPercent}% (scaled: ${scaledPercent}%)`);
                        updateLoadingProgress(scaledPercent, `Downloading... ${downloadPercent}%`);
                    },
                    function (error) {
                        console.error('Error loading GLB:', error);
                        hideLoading();
                    }
                );

            } catch (error) {
                console.error('Error loading world data:', error);
                hideLoading();
            }
        }

        // Helper function for latitude/longitude lines
        function latLngToVector3(lat, lng, radius = 1, height = 0) {
            const phi = (90 - lat) * Math.PI / 180;
            const theta = (lng + 180) * Math.PI / 180;

            const r = radius + height;
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.cos(phi);
            const z = r * Math.sin(phi) * Math.sin(theta);

            return new THREE.Vector3(x, y, z);
        }

        function addLatLongLines() {
            const radius = 1.001; // Slightly larger than globe to prevent z-fighting
            const lineColor = 0x444444;
            const lineMaterial = new THREE.LineBasicMaterial({
                color: lineColor,
                opacity: 0.3,
                transparent: true
            });

            // Add latitude lines (parallels)
            // Every 15 degrees: -75, -60, -45, -30, -15, 0, 15, 30, 45, 60, 75
            for (let lat = -75; lat <= 75; lat += 15) {
                const points = [];
                for (let lng = -180; lng <= 180; lng += 5) {
                    const point = latLngToVector3(lat, lng, radius);
                    points.push(point);
                }
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, lineMaterial);
                globe.add(line);
            }

            // Add longitude lines (meridians)
            // Every 15 degrees
            for (let lng = -180; lng < 180; lng += 15) {
                const points = [];
                for (let lat = -90; lat <= 90; lat += 5) {
                    const point = latLngToVector3(lat, lng, radius);
                    points.push(point);
                }
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, lineMaterial);
                globe.add(line);
            }

            // Add equator with different color for emphasis
            const equatorMaterial = new THREE.LineBasicMaterial({
                color: 0x666666,
                opacity: 0.5,
                transparent: true
            });
            const equatorPoints = [];
            for (let lng = -180; lng <= 180; lng += 2) {
                const point = latLngToVector3(0, lng, radius);
                equatorPoints.push(point);
            }
            const equatorGeometry = new THREE.BufferGeometry().setFromPoints(equatorPoints);
            const equator = new THREE.Line(equatorGeometry, equatorMaterial);
            globe.add(equator);

            // Add prime meridian with different color
            const primeMeridianMaterial = new THREE.LineBasicMaterial({
                color: 0x666666,
                opacity: 0.5,
                transparent: true
            });
            const primeMeridianPoints = [];
            for (let lat = -90; lat <= 90; lat += 2) {
                const point = latLngToVector3(lat, 0, radius);
                primeMeridianPoints.push(point);
            }
            const primeMeridianGeometry = new THREE.BufferGeometry().setFromPoints(primeMeridianPoints);
            const primeMeridian = new THREE.Line(primeMeridianGeometry, primeMeridianMaterial);
            globe.add(primeMeridian);

            // Add polar axis lines extending from north and south poles
            const axisLineMaterial = new THREE.LineBasicMaterial({
                color: 0x333333,
                opacity: 0.2,
                transparent: true
            });

            // North pole axis (extending upward)
            const northAxisPoints = [
                new THREE.Vector3(0, 1, 0),      // North pole surface
                new THREE.Vector3(0, 2.5, 0)     // Extends 1.5 units above globe
            ];
            const northAxisGeometry = new THREE.BufferGeometry().setFromPoints(northAxisPoints);
            const northAxis = new THREE.Line(northAxisGeometry, axisLineMaterial);
            globe.add(northAxis);

            // South pole axis (extending downward)
            const southAxisPoints = [
                new THREE.Vector3(0, -1, 0),     // South pole surface
                new THREE.Vector3(0, -2.5, 0)    // Extends 1.5 units below globe
            ];
            const southAxisGeometry = new THREE.BufferGeometry().setFromPoints(southAxisPoints);
            const southAxis = new THREE.Line(southAxisGeometry, axisLineMaterial);
            globe.add(southAxis);
        }

        function setupEventListeners() {
            // Pointer events (works with mouse, touch, and pen)
            renderer.domElement.addEventListener('pointerdown', onPointerDown);
            renderer.domElement.addEventListener('pointerup', onPointerUp);
            renderer.domElement.addEventListener('pointermove', onPointerMove);

            // Wheel/zoom event (to track user interaction)
            renderer.domElement.addEventListener('wheel', resetIdleTimer);

            // Window resize
            window.addEventListener('resize', onWindowResize);

            // Search input
            elements.get('country-search').addEventListener('input', onSearchInput);
            elements.get('country-search').addEventListener('keydown', onSearchKeyDown);

            // Quiz buttons
            elements.get('quiz-start-btn').addEventListener('click', showQuizModeSelector);
            elements.get('quiz-next-btn').addEventListener('click', () => {
                // Cancel auto-advance timer if user clicks manually
                if (quizAutoAdvanceTimer) {
                    clearTimeout(quizAutoAdvanceTimer);
                    quizAutoAdvanceTimer = null;
                }

                // Call appropriate next function based on current quiz mode
                if (currentQuizMode === 'identify-flag') {
                    nextFlagQuestion();
                } else if (currentQuizMode === 'name-flag') {
                    nextQuestion();
                }
            });
            elements.get('take-quiz-btn').addEventListener('click', showQuizModeSelector);

            // Zoom out button
            elements.get('zoom-out-btn').addEventListener('click', zoomOutToDefault);

            // Quiz mode selector buttons
            elements.get('name-flag-quiz-btn').addEventListener('click', () => {
                hideQuizModeSelector();
                startQuiz();
            });
            elements.get('identify-flag-quiz-btn').addEventListener('click', startFlagIdentificationQuiz);
            elements.get('find-country-quiz-btn').addEventListener('click', startClickQuiz);
            elements.get('quiz-mode-close').addEventListener('click', hideQuizModeSelector);
            elements.get('quiz-mode-overlay').addEventListener('click', hideQuizModeSelector);

            // Click quiz buttons
            elements.get('click-quiz-close-btn').addEventListener('click', closeClickQuizResults);
            elements.get('click-quiz-results-overlay').addEventListener('click', closeClickQuizResults);

            // Sphere radius controls
            elements.get('sphere-radius-up').addEventListener('click', increaseSphereRadius);
            elements.get('sphere-radius-down').addEventListener('click', decreaseSphereRadius);
            elements.get('sphere-toggle').addEventListener('change', toggleSphere);

            // Edit mode keyboard shortcuts
            window.addEventListener('keydown', onKeyDown);

            // Edit mode wheel event for font size adjustment
            renderer.domElement.addEventListener('wheel', onWheelForLabelResize, { passive: false });

            // Edit mode UI buttons
            elements.get('edit-mode-btn').addEventListener('click', toggleEditMode);
            elements.get('save-config-btn').addEventListener('click', saveLabelConfig);
            elements.get('fine-tune-btn').addEventListener('click', openLabelEditorModal);

            // Color edit mode UI buttons
            elements.get('edit-colors-btn').addEventListener('click', toggleColorEditMode);
            elements.get('save-colors-btn').addEventListener('click', saveColorConfig);

            // Label editor modal buttons
            elements.get('label-editor-close-btn').addEventListener('click', closeLabelEditorModal);
            elements.get('label-editor-overlay').addEventListener('click', closeLabelEditorModal);
            elements.get('label-reset-btn').addEventListener('click', resetLabelToDefault);

            // Label editor sliders
            elements.get('label-offset-x').addEventListener('input', onLabelOffsetChange);
            elements.get('label-offset-y').addEventListener('input', onLabelOffsetChange);
            elements.get('label-offset-z').addEventListener('input', onLabelOffsetChange);
            elements.get('label-scale').addEventListener('input', onLabelScaleChange);
        }

        // Keyboard event handler for edit mode
        function onKeyDown(event) {
            // Don't interfere with typing in input fields
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
                return;
            }

            if (event.key === 'e' || event.key === 'E') {
                toggleEditMode();
            } else if (event.key === 's' || event.key === 'S') {
                if (editMode) {
                    saveLabelConfig();
                }
            }
        }

        // Wheel event handler for label font size adjustment in edit mode
        function onWheelForLabelResize(event) {
            if (editMode && selectedLabel) {
                event.preventDefault();

                const countryName = selectedLabel.userData.countryName;
                if (!labelConfig[countryName]) {
                    labelConfig[countryName] = {};
                }

                // Get current font size or default
                let currentFontSize = labelConfig[countryName].fontSize || 32;
                let currentScale = labelConfig[countryName].scale || selectedLabel.scale.x;

                // Adjust scale based on wheel delta
                const scaleDelta = event.deltaY > 0 ? 0.95 : 1.05;
                currentScale *= scaleDelta;
                currentFontSize *= scaleDelta;

                // Clamp values
                currentScale = Math.max(0.1, Math.min(3.0, currentScale));
                currentFontSize = Math.max(8, Math.min(128, currentFontSize));

                // Update label scale
                selectedLabel.scale.set(currentScale, currentScale, currentScale);

                // Update selection helper scale
                if (selectionHelper) {
                    selectionHelper.scale.set(currentScale, currentScale, currentScale);
                }

                // Store in config
                labelConfig[countryName].fontSize = currentFontSize;
                labelConfig[countryName].scale = currentScale;

                console.log(`${countryName}: fontSize=${currentFontSize.toFixed(1)}, scale=${currentScale.toFixed(2)}`);
            }
        }

        // Zoom out to default view
        function zoomOutToDefault() {
            const targetDistance = initialCameraDistance; // Return to initial camera distance
            const currentPos = camera.position.clone();
            const currentDistance = currentPos.length();

            // Normalize direction
            const direction = currentPos.normalize();

            // Calculate target position
            const targetPos = direction.multiplyScalar(targetDistance);

            // Animate zoom out
            const duration = 1000; // ms
            const startTime = Date.now();
            const startDist = currentDistance;

            function animateZoom() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // Ease out cubic
                const easeProgress = 1 - Math.pow(1 - progress, 3);

                // Interpolate distance
                const newDistance = startDist + (targetDistance - startDist) * easeProgress;

                // Update camera position
                const newPos = currentPos.clone().normalize().multiplyScalar(newDistance);
                camera.position.copy(newPos);
                camera.lookAt(0, 0, 0);
                controls.update();

                if (progress < 1) {
                    requestAnimationFrame(animateZoom);
                }
            }

            animateZoom();
        }

        // Toggle edit mode
        function toggleEditMode() {
            editMode = !editMode;

            const editBtn = elements.get('edit-mode-btn');
            const saveBtn = elements.get('save-config-btn');

            if (editMode) {
                console.log('Edit mode ENABLED - Click labels to select, drag to move, wheel to resize');
                // Make all labels visible for editing
                countryLabels.forEach(label => label.visible = true);
                // Disable orbit controls while dragging labels
                controls.enableRotate = true; // Still allow rotation when not dragging

                // Update UI
                addClass(editBtn, 'active');
                setText(editBtn, 'Exit Edit Mode');
                show(saveBtn);
            } else {
                console.log('Edit mode DISABLED');
                // Deselect any selected label
                if (selectedLabel) {
                    deselectLabel();
                }
                // Restore normal visibility
                updateLabelVisibility();

                // Update UI
                removeClass(editBtn, 'active');
                setText(editBtn, 'Edit Labels');
                hide(saveBtn);
            }
        }

        // Select a label in edit mode
        function selectLabel(label) {
            // Deselect previous label
            if (selectedLabel) {
                deselectLabel();
            }

            selectedLabel = label;

            // Create visual indicator (a wireframe box around the label)
            if (!selectionHelper) {
                const helperGeometry = new THREE.PlaneGeometry(
                    label.geometry.parameters.width * 1.1,
                    label.geometry.parameters.height * 1.1
                );
                const helperMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.8,
                    depthTest: false,
                    depthWrite: false
                });
                selectionHelper = new THREE.Mesh(helperGeometry, helperMaterial);
                scene.add(selectionHelper);
            }

            // Position helper at label
            selectionHelper.position.copy(label.position);
            selectionHelper.quaternion.copy(label.quaternion);
            selectionHelper.visible = true;

            // Show fine tune button
            show(elements.get('fine-tune-btn'));

            console.log(`Selected: ${label.userData.countryName}`);
        }

        // Deselect current label
        function deselectLabel() {
            if (selectionHelper) {
                selectionHelper.visible = false;
            }
            selectedLabel = null;

            // Hide fine tune button
            hide(elements.get('fine-tune-btn'));
        }

        // Resize selected label by a multiplier
        function resizeSelectedLabel(multiplier) {
            if (!selectedLabel) return;

            const countryName = selectedLabel.userData.countryName;
            if (!labelConfig[countryName]) {
                labelConfig[countryName] = {};
            }

            // Get current font size or default
            let currentFontSize = labelConfig[countryName].fontSize || 32;
            let currentScale = labelConfig[countryName].scale || selectedLabel.scale.x;

            // Apply multiplier
            currentScale *= multiplier;
            currentFontSize *= multiplier;

            // Clamp values
            currentScale = Math.max(0.1, Math.min(3.0, currentScale));
            currentFontSize = Math.max(8, Math.min(128, currentFontSize));

            // Update label scale
            selectedLabel.scale.set(currentScale, currentScale, currentScale);

            // Update selection helper scale
            if (selectionHelper) {
                selectionHelper.scale.set(currentScale, currentScale, currentScale);
            }

            // Store in config
            labelConfig[countryName].fontSize = currentFontSize;
            labelConfig[countryName].scale = currentScale;

            console.log(`${countryName}: fontSize=${currentFontSize.toFixed(1)}, scale=${currentScale.toFixed(2)}`);
        }

        // Save label configuration to JSON file
        function saveLabelConfig() {
            const dataStr = JSON.stringify(labelConfig, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);

            const link = document.createElement('a');
            link.href = url;
            link.download = 'label-config.json';
            link.click();

            URL.revokeObjectURL(url);
            console.log('Label configuration saved! Countries configured:', Object.keys(labelConfig).length);
        }

        // Load label configuration from JSON
        function loadLabelConfig() {
            // Try to fetch label-config.json
            fetch('label-config.json')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('No saved config found');
                    }
                    return response.json();
                })
                .then(config => {
                    labelConfig = config;
                    console.log('Loaded label configuration for', Object.keys(labelConfig).length, 'countries');
                    // Apply loaded config to existing labels
                    applyLabelConfig();
                })
                .catch(err => {
                    console.log('No label config file found, using defaults');
                });
        }

        // Apply saved configuration to labels
        function applyLabelConfig() {
            countryLabels.forEach(label => {
                const countryName = label.userData.countryName;
                const config = labelConfig[countryName];

                if (config) {
                    // Apply custom position
                    if (config.position) {
                        label.position.set(config.position.x, config.position.y, config.position.z);
                        label.lookAt(label.position.clone().multiplyScalar(2));
                    }

                    // Apply custom scale
                    if (config.scale) {
                        label.scale.set(config.scale, config.scale, config.scale);
                    }
                }
            });
        }

        function loadColorConfig() {
            // Try to fetch country-colors.json
            fetch('country-colors.json')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('No saved color config found');
                    }
                    return response.json();
                })
                .then(config => {
                    colorConfig = config;
                    console.log('Loaded color configuration for', Object.keys(colorConfig).length, 'countries');
                    // Apply loaded config to existing country meshes
                    applyColorConfig();
                })
                .catch(err => {
                    console.log('No color config file found, using default colors');
                });
        }

        // Apply saved color configuration to country meshes
        function applyColorConfig() {
            countries.forEach(country => {
                const countryName = country.userData.name;
                const color = colorConfig[countryName];

                if (color) {
                    // Apply color to the country mesh vertices
                    const geometry = country.geometry;
                    const colorAttribute = geometry.getAttribute('color');

                    if (colorAttribute) {
                        const colors = colorAttribute.array;
                        const vertexCount = colors.length / 3;

                        // Set all vertices to the saved color
                        for (let i = 0; i < vertexCount; i++) {
                            colors[i * 3] = color[0];
                            colors[i * 3 + 1] = color[1];
                            colors[i * 3 + 2] = color[2];
                        }

                        colorAttribute.needsUpdate = true;
                    }
                }
            });
        }

        // Open label editor modal for selected label
        function openLabelEditorModal() {
            if (!selectedLabel) return;

            const countryName = selectedLabel.userData.countryName;
            const modal = elements.get('label-editor-modal');
            const title = elements.get('label-editor-title');

            setText(title, `Edit Label: ${countryName}`);

            // Get current position (or default)
            const currentPos = selectedLabel.position.clone();
            const defaultPos = labelDefaults[countryName].position;

            // Calculate offsets from default
            const offsetX = currentPos.x - defaultPos.x;
            const offsetY = currentPos.y - defaultPos.y;
            const offsetZ = currentPos.z - defaultPos.z;

            // Get current scale
            const currentScale = selectedLabel.scale.x;

            // Update slider values
            elements.get('label-offset-x').value = offsetX;
            elements.get('label-offset-y').value = offsetY;
            elements.get('label-offset-z').value = offsetZ;
            elements.get('label-scale').value = currentScale;

            // Update value displays
            setText(elements.get('label-offset-x-value'), offsetX.toFixed(2));
            setText(elements.get('label-offset-y-value'), offsetY.toFixed(2));
            setText(elements.get('label-offset-z-value'), offsetZ.toFixed(2));
            setText(elements.get('label-scale-value'), currentScale.toFixed(1));

            show(modal);
        }

        // Close label editor modal
        function closeLabelEditorModal() {
            const modal = elements.get('label-editor-modal');
            hide(modal);
        }

        // Handle position offset changes from sliders
        function onLabelOffsetChange(event) {
            if (!selectedLabel) return;

            const countryName = selectedLabel.userData.countryName;
            const defaultPos = labelDefaults[countryName].position;

            // Get offsets from sliders
            const offsetX = parseFloat(elements.get('label-offset-x').value);
            const offsetY = parseFloat(elements.get('label-offset-y').value);
            const offsetZ = parseFloat(elements.get('label-offset-z').value);

            // Update value displays
            setText(elements.get('label-offset-x-value'), offsetX.toFixed(2));
            setText(elements.get('label-offset-y-value'), offsetY.toFixed(2));
            setText(elements.get('label-offset-z-value'), offsetZ.toFixed(2));

            // Apply new position
            const newPos = new THREE.Vector3(
                defaultPos.x + offsetX,
                defaultPos.y + offsetY,
                defaultPos.z + offsetZ
            );

            selectedLabel.position.copy(newPos);
            selectedLabel.lookAt(newPos.clone().multiplyScalar(2));

            // Update selection helper
            if (selectionHelper) {
                selectionHelper.position.copy(newPos);
                selectionHelper.quaternion.copy(selectedLabel.quaternion);
            }

            // Store in config
            if (!labelConfig[countryName]) {
                labelConfig[countryName] = {};
            }
            labelConfig[countryName].position = {
                x: newPos.x,
                y: newPos.y,
                z: newPos.z
            };
        }

        // Handle scale changes from slider
        function onLabelScaleChange(event) {
            if (!selectedLabel) return;

            const countryName = selectedLabel.userData.countryName;
            const scale = parseFloat(elements.get('label-scale').value);

            // Update value display
            setText(elements.get('label-scale-value'), scale.toFixed(1));

            // Apply scale
            selectedLabel.scale.set(scale, scale, scale);

            // Update selection helper
            if (selectionHelper) {
                selectionHelper.scale.set(scale, scale, scale);
            }

            // Store in config
            if (!labelConfig[countryName]) {
                labelConfig[countryName] = {};
            }
            labelConfig[countryName].scale = scale;
            labelConfig[countryName].fontSize = 32 * scale; // Proportional font size
        }

        // Reset label to default position and scale
        function resetLabelToDefault() {
            if (!selectedLabel) return;

            const countryName = selectedLabel.userData.countryName;
            const defaults = labelDefaults[countryName];

            // Reset position
            selectedLabel.position.copy(defaults.position);
            selectedLabel.lookAt(defaults.position.clone().multiplyScalar(2));

            // Reset scale
            selectedLabel.scale.set(1, 1, 1);

            // Update selection helper
            if (selectionHelper) {
                selectionHelper.position.copy(defaults.position);
                selectionHelper.quaternion.copy(selectedLabel.quaternion);
                selectionHelper.scale.set(1, 1, 1);
            }

            // Remove from config
            delete labelConfig[countryName];

            // Update sliders
            elements.get('label-offset-x').value = 0;
            elements.get('label-offset-y').value = 0;
            elements.get('label-offset-z').value = 0;
            elements.get('label-scale').value = 1.0;

            setText(elements.get('label-offset-x-value'), '0.00');
            setText(elements.get('label-offset-y-value'), '0.00');
            setText(elements.get('label-offset-z-value'), '0.00');
            setText(elements.get('label-scale-value'), '1.0');

            console.log(`${countryName} reset to default`);

            // Provide haptic feedback if available
            if (navigator.vibrate) {
                navigator.vibrate(50);
            }
        }

        // Toggle color edit mode
        function toggleColorEditMode() {
            colorEditMode = !colorEditMode;

            const editBtn = elements.get('edit-colors-btn');
            const saveBtn = elements.get('save-colors-btn');

            if (colorEditMode) {
                console.log('Color edit mode ENABLED - Click countries to change colors');

                // Update UI
                addClass(editBtn, 'active');
                setText(editBtn, 'Exit Color Edit');
                show(saveBtn);

                // Disable label edit mode if active
                if (editMode) {
                    toggleEditMode();
                }
            } else {
                console.log('Color edit mode DISABLED');

                // Update UI
                removeClass(editBtn, 'active');
                setText(editBtn, 'Edit Colors');
                hide(saveBtn);
            }
        }

        // Change country color to a random color from palette
        function changeCountryColor(country) {
            if (!country || !colorEditMode) return;

            const countryName = country.userData.name;

            // Pick a random color from the palette
            const randomColor = COLOR_PALETTE[Math.floor(Math.random() * COLOR_PALETTE.length)];

            // Apply color to the country mesh
            const geometry = country.geometry;
            const colorAttribute = geometry.getAttribute('color');

            if (colorAttribute) {
                const colors = colorAttribute.array;
                const vertexCount = colors.length / 3;

                // Set all vertices to the new color
                for (let i = 0; i < vertexCount; i++) {
                    colors[i * 3] = randomColor[0];
                    colors[i * 3 + 1] = randomColor[1];
                    colors[i * 3 + 2] = randomColor[2];
                }

                colorAttribute.needsUpdate = true;
            }

            // Store in config
            colorConfig[countryName] = randomColor;

            console.log(`${countryName} color changed to [${randomColor.join(', ')}]`);

            // Provide haptic feedback if available
            if (navigator.vibrate) {
                navigator.vibrate(30);
            }
        }

        // Save color configuration to JSON file
        function saveColorConfig() {
            const dataStr = JSON.stringify(colorConfig, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);

            const link = document.createElement('a');
            link.href = url;
            link.download = 'country-colors.json';
            link.click();

            URL.revokeObjectURL(url);
            console.log('Color configuration saved! Countries configured:', Object.keys(colorConfig).length);
        }

        let currentSphereRadius = 1.014;

        function toggleSphere(event) {
            if (baseSphere) {
                baseSphere.visible = event.target.checked;
            }
        }

        function increaseSphereRadius() {
            currentSphereRadius += 0.001;
            updateSphereRadius();
        }

        function decreaseSphereRadius() {
            currentSphereRadius -= 0.001;
            updateSphereRadius();
        }

        function updateSphereRadius() {
            // Update the display
            setText(elements.get('sphere-radius-value'), currentSphereRadius.toFixed(3));

            // Remove old sphere
            if (baseSphere) {
                globe.remove(baseSphere);
                baseSphere.geometry.dispose();
                baseSphere.material.dispose();
            }

            // Create new sphere with updated radius
            const sphereGeometry = new THREE.SphereGeometry(currentSphereRadius, 64, 64);
            const sphereMaterial = new THREE.MeshPhongMaterial({
                color: 0x001a33, // Dark blue ocean color
                transparent: false,
                opacity: 1.0,
                side: THREE.BackSide, // Render inside surface to block artifacts
                depthWrite: true,
                shininess: 30, // Moderate reflectivity
                specular: 0x222222 // Subtle highlights
            });
            baseSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            globe.add(baseSphere);

            console.log('Sphere radius updated to:', currentSphereRadius.toFixed(3));
        }

        function onPointerDown(event) {
            // Update mouse coordinates for raycasting
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            mouseDownPos.x = event.clientX;
            mouseDownPos.y = event.clientY;
            isDragging = false;
            longPressTriggered = false;

            // Edit mode: Start dragging selected label if clicked on it or its helper
            if (editMode && selectedLabel) {
                raycaster.setFromCamera(mouse, camera);
                const objectsToCheck = [selectedLabel];
                if (selectionHelper && selectionHelper.visible) {
                    objectsToCheck.push(selectionHelper);
                }
                const labelIntersects = raycaster.intersectObjects(objectsToCheck);

                if (labelIntersects.length > 0) {
                    isDraggingLabel = true;
                    controls.enableRotate = false; // Disable rotation while dragging label

                    // Start long-press timer for resize down
                    longPressTimer = setTimeout(() => {
                        if (!isDragging && selectedLabel) {
                            longPressTriggered = true;
                            resizeSelectedLabel(0.9); // Decrease size by 10%
                            // Provide haptic feedback if available
                            if (navigator.vibrate) {
                                navigator.vibrate(50);
                            }
                        }
                    }, 500); // 500ms for long press
                }
            }
        }

        function onPointerUp(event) {
            // Update mouse coordinates for raycasting (critical for mobile taps)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Clear long press timer
            if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
            }

            // Handle label dragging end
            if (isDraggingLabel) {
                isDraggingLabel = false;
                controls.enableRotate = true;

                // If long press was triggered, don't process as tap
                if (longPressTriggered) {
                    longPressTriggered = false;
                    return;
                }

                // Check if this was just a quick tap (not a drag)
                const deltaX = Math.abs(event.clientX - mouseDownPos.x);
                const deltaY = Math.abs(event.clientY - mouseDownPos.y);
                if (deltaX < 5 && deltaY < 5 && selectedLabel) {
                    // Detect double-tap
                    const currentTime = Date.now();
                    const timeSinceLastTap = currentTime - lastTapTime;

                    if (timeSinceLastTap < 300) { // Double tap within 300ms
                        resizeSelectedLabel(1.1); // Increase size by 10%
                        // Provide haptic feedback if available
                        if (navigator.vibrate) {
                            navigator.vibrate(50);
                        }
                        lastTapTime = 0; // Reset to prevent triple-tap
                    } else {
                        lastTapTime = currentTime;
                    }
                }
                return;
            }

            // If this was a drag operation, ignore the pointer release
            if (isDragging) {
                isDragging = false; // Reset for next interaction
                return;
            }

            // Edit mode: Check for label clicks first
            if (editMode) {
                raycaster.setFromCamera(mouse, camera);
                const labelIntersects = raycaster.intersectObjects(countryLabels);

                if (labelIntersects.length > 0) {
                    selectLabel(labelIntersects[0].object);
                    return; // Don't process country clicks in edit mode
                }
            }

            // Color edit mode: Change country color on click
            if (colorEditMode) {
                raycaster.setFromCamera(mouse, camera);
                const colorIntersects = raycaster.intersectObjects(countries);

                if (colorIntersects.length > 0) {
                    changeCountryColor(colorIntersects[0].object);
                    return; // Don't process normal country selection in color edit mode
                }
            }

            // Not a drag - treat as a click
            // Handle click logic
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(countries);

            if (intersects.length > 0) {
                selectedCountry = intersects[0].object;
                console.log('Selected country:', selectedCountry.userData.name);

                // Handle click quiz answer
                if (clickQuizActive) {
                    handleClickQuizAnswer(selectedCountry.userData.name);
                    return; // Don't process normal country selection
                }

                // Center on clicked country (if not in quiz mode)
                if (!quizActive) {
                    // Track the selected country so it stays highlighted
                    selectedSearchCountry = selectedCountry.userData.name;

                    // Reset all countries to normal state first
                    countries.forEach(c => {
                        c.material.vertexColors = true;
                        c.material.color.setHex(0xffffff);
                        c.material.needsUpdate = true;
                    });

                    // Highlight only the clicked country
                    selectedCountry.material.vertexColors = false;
                    selectedCountry.material.color.setHex(0xFFFFFF);
                    selectedCountry.material.needsUpdate = true;

                    rotateGlobeToCountry(selectedCountry);
                    // Show the flag for the clicked country
                    showWavingFlag(selectedCountry.userData.name);
                }
            }
        }

        function onPointerMove(event) {
            // Track user interaction and reset idle timer
            resetIdleTimer();

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Handle label dragging in edit mode
            if (isDraggingLabel && selectedLabel) {
                // Project mouse position onto sphere surface
                raycaster.setFromCamera(mouse, camera);

                // Create a sphere to intersect with (at radius 1.02 where labels are)
                const sphereGeometry = new THREE.SphereGeometry(1.02, 32, 32);
                const sphereMesh = new THREE.Mesh(sphereGeometry);
                const sphereIntersects = raycaster.intersectObject(sphereMesh);

                if (sphereIntersects.length > 0) {
                    const newPosition = sphereIntersects[0].point;
                    selectedLabel.position.copy(newPosition);

                    // Update label orientation to face outward
                    selectedLabel.lookAt(newPosition.clone().multiplyScalar(2));

                    // Update selection helper position
                    if (selectionHelper) {
                        selectionHelper.position.copy(newPosition);
                        selectionHelper.quaternion.copy(selectedLabel.quaternion);
                    }

                    // Store the new position in config
                    const countryName = selectedLabel.userData.countryName;
                    if (!labelConfig[countryName]) {
                        labelConfig[countryName] = {};
                    }
                    labelConfig[countryName].position = {
                        x: newPosition.x,
                        y: newPosition.y,
                        z: newPosition.z
                    };
                }

                return; // Don't process other mouse events while dragging
            }

            // Detect dragging in real-time (pointer is down and has moved)
            if (event.buttons === 1) { // Primary button is pressed
                const deltaX = Math.abs(event.clientX - mouseDownPos.x);
                const deltaY = Math.abs(event.clientY - mouseDownPos.y);
                if (deltaX > 5 || deltaY > 5) {
                    isDragging = true;
                }
            }

            // Skip hover effects during quiz or while dragging
            if (quizActive || isDragging) {
                return;
            }

            // Raycast for hover effects (cursor change only)
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(countries);

            // Change cursor on hover
            if (intersects.length > 0) {
                document.body.style.cursor = 'pointer';
            } else {
                document.body.style.cursor = 'default';
            }
        }

        function focusOnCountry(country) {
            // Smooth camera movement to focus on country
            const targetPosition = country.position.clone().multiplyScalar(2);
            
            // Simple camera animation (you could use a tween library for smoother animation)
            const startPosition = camera.position.clone();
            const duration = 1000; // ms
            const startTime = Date.now();
            
            function animateCamera() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Ease out cubic
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                camera.position.lerpVectors(startPosition, targetPosition, easeProgress);
                camera.lookAt(0, 0, 0);
                
                if (progress < 1) {
                    requestAnimationFrame(animateCamera);
                }
            }
            
            animateCamera();
        }


        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Recalculate camera distance for new viewport size
            const aspectRatio = window.innerWidth / window.innerHeight;
            const fov = 75 * Math.PI / 180;
            const isMobile = window.innerWidth <= 768;

            let cameraDistance;
            let targetPercentage = isMobile ? 0.85 : 0.65;

            if (aspectRatio >= 1) {
                cameraDistance = (1 / Math.tan(fov / 2)) / targetPercentage;
            } else {
                const horizontalFov = 2 * Math.atan(Math.tan(fov / 2) * aspectRatio);
                cameraDistance = (1 / Math.tan(horizontalFov / 2)) / targetPercentage;
            }

            // Maintain current camera angles but update distance
            const currentDistance = camera.position.length();
            const direction = camera.position.clone().normalize();

            // Update camera position with new distance
            camera.position.copy(direction.multiplyScalar(cameraDistance));

            // Center vertically (remove any previous offset)
            camera.position.y = 0;
            camera.lookAt(0, 0, 0);
            controls.update();
        }

        function hideLoading() {
            hide(elements.get('loading'));

            // Keep fun facts rotating even after loading completes

            // Convert progress bar to start button
            const progressBar = elements.get('loading-progress-bar');
            const startButton = elements.get('start-button');

            if (progressBar) {
                hide(progressBar);
            }

            if (startButton) {
                show(startButton);
            }
        }

        // ============================================
        // QUIZ FUNCTIONALITY
        // ============================================

        // Build cache of country centroids for distance calculations
        function buildCountryCentroidsCache() {
            countryCentroids = [];

            // Get unique country names
            const uniqueCountries = new Map();

            countries.forEach(mesh => {
                const countryName = mesh.userData.name;
                if (!uniqueCountries.has(countryName)) {
                    uniqueCountries.set(countryName, []);
                }
                uniqueCountries.get(countryName).push(mesh);
            });

            // Calculate centroid for each unique country (average of all its meshes' centroids)
            uniqueCountries.forEach((meshes, countryName) => {
                const centroid = new THREE.Vector3(0, 0, 0);
                let totalVertices = 0;

                meshes.forEach(mesh => {
                    const geometry = mesh.geometry;
                    const positions = geometry.attributes.position;

                    for (let i = 0; i < positions.count; i++) {
                        const vertex = new THREE.Vector3(
                            positions.getX(i),
                            positions.getY(i),
                            positions.getZ(i)
                        );
                        // Apply world transform
                        mesh.localToWorld(vertex);
                        centroid.add(vertex);
                        totalVertices++;
                    }
                });

                if (totalVertices > 0) {
                    centroid.divideScalar(totalVertices);
                    // Normalize to sphere surface (in case of small precision errors)
                    centroid.normalize();

                    countryCentroids.push({
                        name: countryName,
                        centroid: centroid,
                        meshRefs: meshes
                    });
                }
            });

            console.log(`Built centroids cache for ${countryCentroids.length} countries`);
        }

        // Create text label using canvas
        function createTextLabel(text) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');

            // Set canvas size
            canvas.width = 512;
            canvas.height = 128;

            // Configure text style
            context.font = '32px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';

            // Draw dark gray text for contrast with ocean
            context.fillStyle = '#686868';
            context.fillText(text, canvas.width / 2, canvas.height / 2);

            // Create texture from canvas
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            return texture;
        }

        // Create labels for all countries
        function createCountryLabels() {
            countryCentroids.forEach(countryData => {
                const countryName = countryData.name;

                // Determine country size category
                let sizeCategory = 'medium'; // Default
                let labelWidth, labelHeight;

                if (LARGE_COUNTRIES.has(countryName)) {
                    sizeCategory = 'large';
                    labelWidth = 0.25;  // Larger labels for large countries
                    labelHeight = 0.065;
                } else if (SMALL_COUNTRIES.has(countryName)) {
                    sizeCategory = 'small';
                    labelWidth = 0.12;  // Smaller labels for small countries
                    labelHeight = 0.032;
                } else {
                    sizeCategory = 'medium';
                    labelWidth = 0.18;  // Medium labels for medium countries
                    labelHeight = 0.048;
                }

                const labelTexture = createTextLabel(countryName);

                // Create material with transparency
                const labelMaterial = new THREE.MeshBasicMaterial({
                    map: labelTexture,
                    transparent: true,
                    opacity: 1.0,
                    side: THREE.DoubleSide,
                    depthTest: false, // Disabled to ensure labels render on top
                    depthWrite: false
                });

                // Create plane geometry with size based on country category
                const labelGeometry = new THREE.PlaneGeometry(labelWidth, labelHeight);
                const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);

                // Position label at country centroid, slightly above surface
                const labelPosition = countryData.centroid.clone().multiplyScalar(1.02);
                labelMesh.position.copy(labelPosition);

                // Orient label to face outward from globe center
                labelMesh.lookAt(countryData.centroid.clone().multiplyScalar(2));

                // Store reference to country name and size category
                labelMesh.userData.countryName = countryName;
                labelMesh.userData.sizeCategory = sizeCategory;

                // Store default position and scale for reset functionality
                labelDefaults[countryName] = {
                    position: labelPosition.clone(),
                    scale: 1.0,
                    width: labelWidth,
                    height: labelHeight
                };

                // Initially hide all labels
                labelMesh.visible = false;

                // Add to globe so it rotates with it
                globe.add(labelMesh);
                countryLabels.push(labelMesh);
            });

            console.log(`Created ${countryLabels.length} country labels`);
        }

        // Create borders for all countries using boundary edge detection
        function createCountryBorders() {
            console.log('Creating country borders...');

            // Iterate through all country meshes
            countries.forEach(countryMesh => {
                const geometry = countryMesh.geometry;
                const positionAttribute = geometry.attributes.position;

                if (!positionAttribute) return;

                // Build edge map to find boundary edges (edges that belong to only one triangle)
                const edgeMap = new Map();
                const indices = geometry.index ? geometry.index.array : null;

                if (!indices) return; // Skip if no index buffer

                // Process all triangles
                for (let i = 0; i < indices.length; i += 3) {
                    const a = indices[i];
                    const b = indices[i + 1];
                    const c = indices[i + 2];

                    // Add the three edges of this triangle
                    addEdge(edgeMap, a, b);
                    addEdge(edgeMap, b, c);
                    addEdge(edgeMap, c, a);
                }

                // Collect boundary edges (edges that appear only once)
                const boundaryEdges = [];
                edgeMap.forEach((count, key) => {
                    if (count === 1) {
                        const [v1, v2] = key.split(',').map(Number);
                        boundaryEdges.push(v1, v2);
                    }
                });

                if (boundaryEdges.length === 0) return;

                // Create geometry from boundary edges
                const borderGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(boundaryEdges.length * 3);

                for (let i = 0; i < boundaryEdges.length; i++) {
                    const vertexIndex = boundaryEdges[i];
                    positions[i * 3] = positionAttribute.getX(vertexIndex);
                    positions[i * 3 + 1] = positionAttribute.getY(vertexIndex);
                    positions[i * 3 + 2] = positionAttribute.getZ(vertexIndex);
                }

                borderGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                // Create line material with dark gray color
                const lineMaterial = new THREE.LineBasicMaterial({
                    color: 0x333333,
                    linewidth: 1
                });

                // Create line segments from boundary edges
                const borderLines = new THREE.LineSegments(borderGeometry, lineMaterial);

                // Copy the country mesh's transform
                borderLines.position.copy(countryMesh.position);
                borderLines.rotation.copy(countryMesh.rotation);
                borderLines.scale.copy(countryMesh.scale);

                // Add to same parent as country mesh
                if (countryMesh.parent) {
                    countryMesh.parent.add(borderLines);
                }

                // Initially hide borders (only show when zoomed in)
                borderLines.visible = false;

                countryBorders.push(borderLines);
            });

            console.log(`Created borders for ${countryBorders.length} countries`);
        }

        // Helper function to add edges to the edge map
        function addEdge(edgeMap, v1, v2) {
            // Create a consistent key regardless of vertex order
            const key = v1 < v2 ? `${v1},${v2}` : `${v2},${v1}`;
            edgeMap.set(key, (edgeMap.get(key) || 0) + 1);
        }

        // Calculate great circle distance between two countries (returns radians)
        // On a unit sphere, the great circle distance is the angle between two vectors
        function calculateGreatCircleDistance(country1, country2) {
            // Use dot product to get cosine of angle
            const dotProduct = country1.centroid.dot(country2.centroid);
            // Clamp to [-1, 1] to handle floating point errors
            const clampedDot = Math.max(-1, Math.min(1, dotProduct));
            // Arc cosine gives us the angle in radians (which is the distance on unit sphere)
            return Math.acos(clampedDot);
        }

        // Generate a quiz question with geographically close options
        function generateQuizQuestion() {
            // Filter out countries already used in this quiz
            const availableCountries = countryCentroids.filter(c => !usedQuizCountries.includes(c.name));

            if (availableCountries.length < 4) {
                console.error('Not enough unused countries for quiz');
                return null;
            }

            // Select random country from available countries as the correct answer
            const correctIndex = Math.floor(Math.random() * availableCountries.length);
            const correctCountry = availableCountries[correctIndex];

            // Mark this country as used
            usedQuizCountries.push(correctCountry.name);

            // Calculate distances to all other countries (including used ones for distractors)
            const distancesWithCountries = countryCentroids
                .filter(country => country.name !== correctCountry.name)
                .map(country => ({
                    country: country,
                    distance: calculateGreatCircleDistance(correctCountry, country)
                }));

            // Sort by distance (ascending - closest first)
            distancesWithCountries.sort((a, b) => a.distance - b.distance);

            // Select 3 closest countries as distractors
            const distractors = distancesWithCountries
                .slice(0, 3)
                .map(item => item.country.name);

            // Combine correct answer with distractors
            const allOptions = [correctCountry.name, ...distractors];

            // Shuffle the options randomly
            const shuffledOptions = allOptions.sort(() => Math.random() - 0.5);

            return {
                correctCountry: correctCountry.name,
                options: shuffledOptions,
                countryObj: correctCountry
            };
        }

        // Start the quiz
        function startQuiz() {
            quizActive = true;
            currentQuizMode = 'name-flag';
            quizScore = 0;
            quizQuestionsAnswered = 0;
            usedQuizCountries = []; // Reset list of used countries

            // Disable auto-rotation during quiz
            autoRotateEnabled = false;
            controls.autoRotate = false;
            // Clear any pending idle timeout
            if (idleTimeout) {
                clearTimeout(idleTimeout);
                idleTimeout = null;
            }

            // Add quiz-active class to body for mobile styling
            addClass(document.body, 'quiz-active');

            // Clear any previous quiz options before starting
            const optionsContainer = elements.get('quiz-options');
            optionsContainer.innerHTML = '';

            // Show quiz elements
            show(elements.get('quiz-score'));
            show(elements.get('quiz-question'));

            // Hide start button and previous results
            hide(elements.get('quiz-start-btn'));
            hide(elements.get('quiz-result'));
            elements.get('quiz-next-btn').style.visibility = 'hidden';

            // Reset score display
            updateScoreDisplay();

            // Load first question
            nextQuestion();
        }

        // Load next question
        function nextQuestion() {
            // Generate new question
            currentQuizQuestion = generateQuizQuestion();

            if (!currentQuizQuestion) {
                console.error('Failed to generate quiz question');
                return;
            }

            // Hide result and next button
            hide(elements.get('quiz-result'));
            elements.get('quiz-next-btn').style.visibility = 'hidden';

            // Clear previous options completely
            const optionsContainer = elements.get('quiz-options');
            optionsContainer.innerHTML = '';

            // Small delay to ensure DOM is clean before creating new buttons
            setTimeout(() => {
                // Create option buttons with explicit neutral styling
                currentQuizQuestion.options.forEach(optionName => {
                    const button = document.createElement('button');
                    // Set only the quiz-option class, removing any potential inherited classes
                    button.className = 'quiz-option';
                    // Ensure button is enabled
                    button.disabled = false;
                    // Remove any potential inline styles
                    button.removeAttribute('style');

                    // Create span for country name
                    const nameSpan = document.createElement('span');
                    setText(nameSpan, optionName);
                    button.appendChild(nameSpan);

                    button.dataset.country = optionName;
                    button.addEventListener('click', () => handleQuizAnswer(optionName));
                    optionsContainer.appendChild(button);
                });

                // Highlight country on globe and rotate to it
                highlightQuizCountry(currentQuizQuestion.countryObj);
            }, 0);
        }

        // Highlight the quiz country on the globe
        function highlightQuizCountry(countryObj) {
            // Reset all countries
            countries.forEach(country => {
                country.material.vertexColors = true;
                country.material.color.setHex(0xffffff);
                country.material.needsUpdate = true;
            });

            // Highlight the quiz country with white
            countryObj.meshRefs.forEach(mesh => {
                mesh.material.vertexColors = false;
                mesh.material.color.setHex(0xFFFFFF);
                mesh.material.needsUpdate = true;
            });

            // Rotate globe to center the country
            if (countryObj.meshRefs.length > 0) {
                rotateGlobeToCountry(countryObj.meshRefs[0], true);
            }

            // Disable hover and search interactions during quiz
            selectedSearchCountry = countryObj.name;
        }

        // Handle quiz answer selection
        function handleQuizAnswer(selectedCountry) {
            const isCorrect = selectedCountry === currentQuizQuestion.correctCountry;

            // Update score if correct
            if (isCorrect) {
                quizScore++;
            }
            quizQuestionsAnswered++;

            // Update score display
            updateScoreDisplay();

            // Disable all option buttons
            const optionButtons = document.querySelectorAll('.quiz-option');
            optionButtons.forEach(button => {
                button.disabled = true;

                // Highlight correct and incorrect answers
                if (button.dataset.country === currentQuizQuestion.correctCountry) {
                    addClass(button, 'correct');
                    // Add "CORRECT ANSWER" label to correct answer button
                    const label = document.createElement('span');
                    label.className = 'correct-label';
                    setText(label, 'correct answer');
                    button.appendChild(label);
                } else if (button.dataset.country === selectedCountry && !isCorrect) {
                    addClass(button, 'incorrect');
                }
            });

            // Don't show any result message - button feedback is sufficient
            hide(elements.get('quiz-result'));

            // Show next button or end quiz after 10 questions
            if (quizQuestionsAnswered >= 10) {
                setTimeout(() => {
                    endQuiz();
                }, 2000);
            } else {
                // Show next button for 3 seconds, then auto-advance
                elements.get('quiz-next-btn').style.visibility = 'visible';

                // Clear any existing timer
                if (quizAutoAdvanceTimer) {
                    clearTimeout(quizAutoAdvanceTimer);
                }

                // Set new timer
                quizAutoAdvanceTimer = setTimeout(() => {
                    elements.get('quiz-next-btn').style.visibility = 'hidden';
                    quizAutoAdvanceTimer = null;
                    nextQuestion();
                }, 3000);
            }
        }

        // Update score display
        function updateScoreDisplay() {
            setText(elements.get('quiz-score-value'), quizScore);
            setText(elements.get('quiz-total-value'), quizQuestionsAnswered);
        }

        // End the quiz
        function endQuiz() {
            quizActive = false;
            currentQuizMode = null;

            // Clear auto-advance timer if active
            if (quizAutoAdvanceTimer) {
                clearTimeout(quizAutoAdvanceTimer);
                quizAutoAdvanceTimer = null;
            }

            // Resume auto-rotation after quiz
            // TEMPORARILY DISABLED
            // resumeAutoRotation();

            // Remove quiz-active class from body
            removeClass(document.body, 'quiz-active');

            // Hide quiz elements
            hide(elements.get('quiz-score'));
            hide(elements.get('quiz-question'));

            // Clear options
            elements.get('quiz-options').innerHTML = '';

            // Hide quiz container
            hide(elements.get('quiz-container'));

            // Reset globe highlighting
            selectedSearchCountry = null;
            countries.forEach(country => {
                country.material.vertexColors = true;
                country.material.color.setHex(0xffffff);
                country.material.needsUpdate = true;
            });

            // Show celebration overlay with score
            const percentage = Math.round((quizScore / quizQuestionsAnswered) * 100);
            elements.get('celebration-score').innerHTML = `
                <div style="font-size: 1.5rem; margin-bottom: 10px;">Your Score</div>
                <div>${quizScore} / ${quizQuestionsAnswered}</div>
                <div style="font-size: 2rem; margin-top: 10px;">${percentage}%</div>
            `;

            const overlay = elements.get('quiz-celebration-overlay');
            showFlex(overlay);

            // Trigger confetti effect
            triggerConfetti();

            // Add click event to celebration close button
            elements.get('celebration-close-btn').onclick = function() {
                hide(overlay);
                show(elements.get('quiz-container'));
                elements.get('quiz-next-btn').style.visibility = 'hidden';
                show(elements.get('quiz-start-btn'));
                setText(elements.get('quiz-start-btn'), 'Play Again');
            };
        }

        // Trigger confetti celebration
        function triggerConfetti() {
            // Fire confetti from multiple angles
            const duration = 3000;
            const animationEnd = Date.now() + duration;
            const defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 10001 };

            function randomInRange(min, max) {
                return Math.random() * (max - min) + min;
            }

            const interval = setInterval(function() {
                const timeLeft = animationEnd - Date.now();

                if (timeLeft <= 0) {
                    return clearInterval(interval);
                }

                const particleCount = 50 * (timeLeft / duration);

                // Fire confetti from left
                confetti({
                    ...defaults,
                    particleCount,
                    origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 }
                });

                // Fire confetti from right
                confetti({
                    ...defaults,
                    particleCount,
                    origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 }
                });
            }, 250);
        }

        // Flag Identification Quiz Functions
        let flagQuizRenderer = null;
        let flagQuizScene = null;
        let flagQuizCamera = null;
        let flagQuizMesh = null;
        let flagQuizOriginalPositions = null;
        let flagQuizTime = 0;

        function initFlagQuizRenderer() {
            if (flagQuizRenderer) return; // Already initialized

            // Create flag scene for quiz
            flagQuizScene = new THREE.Scene();
            flagQuizScene.background = null; // Transparent background

            // Create flag camera for quiz display
            flagQuizCamera = new THREE.PerspectiveCamera(45, 560 / 373, 0.1, 1000);
            flagQuizCamera.position.z = 9.5;

            // Create flag renderer for quiz
            flagQuizRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            flagQuizRenderer.setSize(560, 373);
            flagQuizRenderer.setClearColor(0x000000, 0); // Transparent

            // Add lights to flag scene
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            flagQuizScene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            flagQuizScene.add(directionalLight);
        }

        function updateFlagQuizAnimation() {
            if (!flagQuizMesh || !flagQuizOriginalPositions) return;

            flagQuizTime = performance.now() * 0.001 * 3; // Speed factor

            const positions = flagQuizMesh.geometry.attributes.position;
            const coeff = 72;
            const coeff2 = 65;
            const gap = 10;
            const spacing = 30;

            for (let i = 0; i < positions.count; i++) {
                const x = flagQuizOriginalPositions[i * 3];
                const y = flagQuizOriginalPositions[i * 3 + 1];

                // Apply Perlin noise to Z position for wave effect
                positions.array[i * 3 + 2] = 1 +
                    (spacing / 25) *
                    noise.perlin2(
                        x * (gap / coeff) + flagQuizTime,
                        y * (gap / coeff2)
                    );
            }

            positions.needsUpdate = true;
            flagQuizMesh.geometry.computeVertexNormals();
        }

        function displayFlagForQuiz(countryName) {
            // Initialize renderer if needed
            initFlagQuizRenderer();

            // Get ISO code for the country
            const isoCode = countryToISO[countryName];
            if (!isoCode) {
                console.error('No ISO code found for country:', countryName);
                return;
            }

            // Remove old flag if exists
            if (flagQuizMesh) {
                flagQuizScene.remove(flagQuizMesh);
                flagQuizMesh.geometry.dispose();
                // Dispose material and texture properly
                if (flagQuizMesh.material.map) {
                    flagQuizMesh.material.map.dispose();
                }
                flagQuizMesh.material.dispose();
                flagQuizMesh = null;
                flagQuizOriginalPositions = null;
            }

            // Create plane geometry with subdivisions for wave effect
            const flagGeometry = new THREE.PlaneGeometry(10, 6.67, 20, 15);

            // Store reference to this load operation
            const currentLoadIsoCode = isoCode;

            // Load flag texture with callback
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(
                `https://flagcdn.com/w640/${isoCode}.png`,
                function(flagTexture) {
                    // Only proceed if this is still the current quiz question
                    // (prevents race condition if user advances quickly)
                    if (currentQuizQuestion && countryToISO[currentQuizQuestion.correctCountry] === currentLoadIsoCode) {
                        // Texture loaded successfully
                        // Create material
                        const flagMaterial = new THREE.MeshStandardMaterial({
                            map: flagTexture,
                            side: THREE.DoubleSide,
                            roughness: 0.7,
                            metalness: 0.1
                        });

                        // Create mesh
                        const flag = new THREE.Mesh(flagGeometry, flagMaterial);

                        // Store original positions for animation
                        const positions = flag.geometry.attributes.position;
                        const originalPositions = new Float32Array(positions.array);

                        // Update global references
                        flagQuizMesh = flag;
                        flagQuizOriginalPositions = originalPositions;
                        flagQuizScene.add(flagQuizMesh);

                        // Force render with new texture
                        flagQuizRenderer.render(flagQuizScene, flagQuizCamera);

                        // Now that texture is loaded, show the flag display
                        show(elements.get('quiz-flag-display'));
                    } else {
                        // Question changed before texture loaded, dispose texture
                        flagTexture.dispose();
                        flagGeometry.dispose();
                    }
                },
                undefined,
                function(error) {
                    console.error('Error loading flag texture:', error);
                    flagGeometry.dispose();
                }
            );

            // Add the canvas to the quiz flag display but keep it hidden
            const flagDisplay = elements.get('quiz-flag-display');
            flagDisplay.innerHTML = ''; // Clear any existing content
            flagDisplay.appendChild(flagQuizRenderer.domElement);
            hide(flagDisplay); // Keep hidden until texture loads
        }

        function generateFlagQuizQuestion() {
            // Filter out countries already used in this quiz
            const availableCountries = countryCentroids.filter(c => !usedQuizCountries.includes(c.name));

            if (availableCountries.length < 4) {
                console.error('Not enough unused countries for quiz');
                return null;
            }

            // Select random country from available countries as the correct answer
            const correctIndex = Math.floor(Math.random() * availableCountries.length);
            const correctCountry = availableCountries[correctIndex];

            // Mark this country as used
            usedQuizCountries.push(correctCountry.name);

            // Get all other countries for random distractors
            const otherCountries = countryCentroids.filter(country => country.name !== correctCountry.name);

            // Select 3 random distractors
            const shuffledOthers = otherCountries.sort(() => Math.random() - 0.5);
            const distractors = shuffledOthers.slice(0, 3).map(c => c.name);

            // Combine correct answer with distractors
            const allOptions = [correctCountry.name, ...distractors];

            // Shuffle the options randomly
            const shuffledOptions = allOptions.sort(() => Math.random() - 0.5);

            return {
                correctCountry: correctCountry.name,
                options: shuffledOptions,
                countryObj: correctCountry
            };
        }

        function startFlagIdentificationQuiz() {
            hideQuizModeSelector();

            quizActive = true;
            currentQuizMode = 'identify-flag';
            quizScore = 0;
            quizQuestionsAnswered = 0;
            usedQuizCountries = []; // Reset list of used countries

            // Disable auto-rotation during quiz
            autoRotateEnabled = false;
            controls.autoRotate = false;
            if (idleTimeout) {
                clearTimeout(idleTimeout);
                idleTimeout = null;
            }

            // Add quiz-active and flag-quiz-active classes to body
            addClass(document.body, 'quiz-active');
            addClass(document.body, 'flag-quiz-active');

            // Clear any previous quiz options before starting
            const optionsContainer = elements.get('quiz-options');
            optionsContainer.innerHTML = '';

            // Show quiz elements
            show(elements.get('quiz-score'));
            setText(elements.get('quiz-question'), 'Which country does this flag belong to?');
            show(elements.get('quiz-question'));

            // Hide start button and previous results
            hide(elements.get('quiz-start-btn'));
            hide(elements.get('quiz-result'));
            elements.get('quiz-next-btn').style.visibility = 'hidden';
            hide(elements.get('quiz-flag-display'));

            // Reset score display
            updateScoreDisplay();

            // Load first question
            nextFlagQuestion();
        }

        function nextFlagQuestion() {
            // Generate new question
            currentQuizQuestion = generateFlagQuizQuestion();

            if (!currentQuizQuestion) {
                console.error('Failed to generate flag quiz question');
                return;
            }

            // Hide result and next button
            hide(elements.get('quiz-result'));
            elements.get('quiz-next-btn').style.visibility = 'hidden';

            // Display the flag
            displayFlagForQuiz(currentQuizQuestion.correctCountry);

            // Clear previous options completely
            const optionsContainer = elements.get('quiz-options');
            optionsContainer.innerHTML = '';

            // Small delay to ensure DOM is clean before creating new buttons
            setTimeout(() => {
                // Create option buttons with explicit neutral styling
                currentQuizQuestion.options.forEach(optionName => {
                    const button = document.createElement('button');
                    // Set only the quiz-option class, removing any potential inherited classes
                    button.className = 'quiz-option';
                    // Ensure button is enabled
                    button.disabled = false;
                    // Remove any potential inline styles
                    button.removeAttribute('style');

                    // Create span for country name
                    const nameSpan = document.createElement('span');
                    setText(nameSpan, optionName);
                    button.appendChild(nameSpan);

                    button.dataset.country = optionName;
                    button.addEventListener('click', () => handleFlagQuizAnswer(optionName));
                    optionsContainer.appendChild(button);
                });
            }, 0);
        }

        function handleFlagQuizAnswer(selectedCountry) {
            const isCorrect = selectedCountry === currentQuizQuestion.correctCountry;

            // Update score if correct
            if (isCorrect) {
                quizScore++;
            }
            quizQuestionsAnswered++;

            // Update score display
            updateScoreDisplay();

            // Disable all option buttons
            const optionButtons = document.querySelectorAll('.quiz-option');
            optionButtons.forEach(button => {
                button.disabled = true;

                // Highlight correct and incorrect answers
                if (button.dataset.country === currentQuizQuestion.correctCountry) {
                    addClass(button, 'correct');
                    const label = document.createElement('span');
                    label.className = 'correct-label';
                    setText(label, 'correct answer');
                    button.appendChild(label);
                } else if (button.dataset.country === selectedCountry && !isCorrect) {
                    addClass(button, 'incorrect');
                }
            });

            // Don't show any result message
            hide(elements.get('quiz-result'));

            // End quiz after 10 questions
            if (quizQuestionsAnswered >= 10) {
                setTimeout(() => {
                    endFlagQuiz();
                }, 2000);
            } else {
                // Show next button for 3 seconds, then auto-advance
                elements.get('quiz-next-btn').style.visibility = 'visible';

                // Clear any existing timer
                if (quizAutoAdvanceTimer) {
                    clearTimeout(quizAutoAdvanceTimer);
                }

                // Set new timer
                quizAutoAdvanceTimer = setTimeout(() => {
                    elements.get('quiz-next-btn').style.visibility = 'hidden';
                    quizAutoAdvanceTimer = null;
                    nextFlagQuestion();
                }, 3000);
            }
        }

        function endFlagQuiz() {
            quizActive = false;
            currentQuizMode = null;

            // Clear auto-advance timer if active
            if (quizAutoAdvanceTimer) {
                clearTimeout(quizAutoAdvanceTimer);
                quizAutoAdvanceTimer = null;
            }

            // Resume auto-rotation after quiz
            // TEMPORARILY DISABLED
            // resumeAutoRotation();

            // Remove quiz-active and flag-quiz-active classes from body
            removeClass(document.body, 'quiz-active');
            removeClass(document.body, 'flag-quiz-active');

            // Hide quiz elements
            hide(elements.get('quiz-score'));
            hide(elements.get('quiz-question'));
            hide(elements.get('quiz-flag-display'));
            elements.get('quiz-options').innerHTML = '';
            hide(elements.get('quiz-container'));
            elements.get('quiz-next-btn').style.visibility = 'hidden';

            // Show celebration overlay with score
            const percentage = Math.round((quizScore / quizQuestionsAnswered) * 100);
            elements.get('celebration-score').innerHTML = `
                <div style="font-size: 1.5rem; margin-bottom: 10px;">Your Score</div>
                <div>${quizScore} / ${quizQuestionsAnswered}</div>
                <div style="font-size: 2rem; margin-top: 10px;">${percentage}%</div>
            `;

            const overlay = elements.get('quiz-celebration-overlay');
            showFlex(overlay);

            // Trigger confetti effect
            triggerConfetti();

            // Add click event to celebration close button
            elements.get('celebration-close-btn').onclick = function() {
                hide(overlay);
                show(elements.get('quiz-container'));
                elements.get('quiz-next-btn').style.visibility = 'hidden';
                show(elements.get('quiz-start-btn'));
                setText(elements.get('quiz-start-btn'), 'Play Again');
            };
        }

        // Quiz Mode Selector Functions
        function showQuizModeSelector() {
            show(elements.get('quiz-mode-selector'));
        }

        function hideQuizModeSelector() {
            hide(elements.get('quiz-mode-selector'));
        }

        // Click Quiz Functions
        function startClickQuiz() {
            hideQuizModeSelector();

            clickQuizActive = true;
            clickQuizCurrentIndex = 0;
            clickQuizScore = 0;
            clickQuizTimeRemaining = 45000; // 45 seconds
            clickQuizStartTime = Date.now();

            // Select 10 random countries
            const shuffled = [...countryCentroids].sort(() => Math.random() - 0.5);
            clickQuizCountries = shuffled.slice(0, 10).map(c => c.name);

            // Disable auto-rotation and search during quiz
            autoRotateEnabled = false;
            controls.autoRotate = false;
            if (idleTimeout) {
                clearTimeout(idleTimeout);
                idleTimeout = null;
            }

            // Hide search container
            hide(elements.get('search-container'));
            hide(elements.get('take-quiz-btn'));

            // Show click quiz UI
            show(elements.get('click-quiz-container'));
            show(elements.get('click-quiz-timer-bar-container'));

            // Start timer
            clickQuizTimerInterval = setInterval(updateClickQuizTimer, 100);

            // Show first question
            showClickQuizQuestion();
        }

        function showClickQuizQuestion() {
            const countryName = clickQuizCountries[clickQuizCurrentIndex];
            setText(elements.get('click-quiz-country-name'), countryName);
            elements.get('click-quiz-question-counter').textContent =
                `Question ${clickQuizCurrentIndex + 1} of 10`;
            elements.get('click-quiz-score-display').textContent =
                `Score: ${clickQuizScore}/${clickQuizCurrentIndex}`;
        }

        function updateClickQuizTimer() {
            // Calculate elapsed time
            const elapsed = Date.now() - clickQuizStartTime;
            clickQuizTimeRemaining = 45000 - elapsed;

            // Update timer bar
            const percentage = Math.max(0, (clickQuizTimeRemaining / 45000) * 100);
            elements.get('click-quiz-timer-fill').style.height = percentage + '%';

            // End quiz if time runs out
            if (clickQuizTimeRemaining <= 0) {
                endClickQuiz(false);
            }
        }

        function handleClickQuizAnswer(clickedCountryName) {
            const correctCountryName = clickQuizCountries[clickQuizCurrentIndex];

            if (clickedCountryName === correctCountryName) {
                // Correct answer!
                clickQuizScore++;
                showClickQuizFeedback('Correct!', true);

                // Flash country green
                flashCountryColor(clickedCountryName, 0x00ff00);

                // Move to next question after a short delay
                setTimeout(() => {
                    clickQuizCurrentIndex++;

                    if (clickQuizCurrentIndex >= 10) {
                        // Quiz complete!
                        endClickQuiz(true);
                    } else {
                        showClickQuizQuestion();
                    }
                }, 800);
            } else {
                // Wrong answer - deduct 5 seconds
                clickQuizStartTime -= 5000; // Move start time back by 5 seconds
                showClickQuizFeedback('Wrong! -5 seconds', false);

                // Flash country red
                flashCountryColor(clickedCountryName, 0xff0000);
            }
        }

        function showClickQuizFeedback(message, isCorrect) {
            const feedbackEl = elements.get('click-quiz-feedback');
            setText(feedbackEl, message);
            feedbackEl.className = isCorrect ? 'correct' : 'wrong';
            show(feedbackEl);

            setTimeout(() => {
                hide(feedbackEl);
            }, 1000);
        }

        function flashCountryColor(countryName, color) {
            const country = countries.find(c => c.userData.name === countryName);
            if (country) {
                const originalColor = country.material.color.getHex();
                country.material.color.setHex(color);
                country.material.needsUpdate = true;

                setTimeout(() => {
                    country.material.color.setHex(originalColor);
                    country.material.needsUpdate = true;
                }, 500);
            }
        }

        function endClickQuiz(completed) {
            clickQuizActive = false;

            // Clear timer
            if (clickQuizTimerInterval) {
                clearInterval(clickQuizTimerInterval);
                clickQuizTimerInterval = null;
            }

            // Hide quiz UI
            hide(elements.get('click-quiz-container'));
            hide(elements.get('click-quiz-timer-bar-container'));

            // Calculate final time
            const totalTime = 45000;
            const timeUsed = totalTime - Math.max(0, clickQuizTimeRemaining);
            const seconds = (timeUsed / 1000).toFixed(1);

            // Show celebration overlay with score
            const percentage = Math.round((clickQuizScore / clickQuizCurrentIndex) * 100);
            elements.get('celebration-score').innerHTML = `
                <div style="font-size: 1.5rem; margin-bottom: 10px;">Your Score</div>
                <div>${clickQuizScore} / ${clickQuizCurrentIndex}</div>
                <div style="font-size: 2rem; margin-top: 10px;">${percentage}%</div>
                <div style="font-size: 1.2rem; margin-top: 15px; color: #E0E0E0;">
                    ${completed ? `Completed in ${seconds}s` : `Time's Up! ${seconds}s elapsed`}
                </div>
            `;

            const overlay = elements.get('quiz-celebration-overlay');
            showFlex(overlay);

            // Trigger confetti effect
            triggerConfetti();

            // Add click event to celebration close button
            elements.get('celebration-close-btn').onclick = function() {
                hide(overlay);
                // Show search and quiz button again
                show(elements.get('search-container'));
                show(elements.get('take-quiz-btn'));
            };
        }

        function closeClickQuizResults() {
            hide(elements.get('click-quiz-results'));

            // Show search and quiz button again
            show(elements.get('search-container'));
            show(elements.get('take-quiz-btn'));

            // Resume auto-rotation
            // TEMPORARILY DISABLED
            // resumeAutoRotation();
        }

        // Initialize flag renderer (separate Three.js scene for the flag)
        function initFlagRenderer() {
            // Create flag scene
            flagScene = new THREE.Scene();
            flagScene.background = null; // Transparent background

            // Create flag camera (reduced by 40%: 180x120)
            flagCamera = new THREE.PerspectiveCamera(45, 180 / 120, 0.1, 1000);
            flagCamera.position.z = 9.5; // Moved slightly back from 8

            // Create flag renderer (reduced by 40%)
            flagRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            flagRenderer.setSize(180, 120);
            flagRenderer.setClearColor(0x000000, 0); // Transparent

            // Insert the canvas into the flag-container-content, after flag-info
            const flagContainerContent = elements.get('flag-container-content');
            flagContainerContent.appendChild(flagRenderer.domElement);

            // Add lights to flag scene
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            flagScene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            flagScene.add(directionalLight);
        }

        // Create waving flag mesh
        function createWavingFlag(isoCode) {
            // Load flag texture from flagcdn.com (high resolution)
            const textureLoader = new THREE.TextureLoader();
            const flagTexture = textureLoader.load(`https://flagcdn.com/w640/${isoCode}.png`);

            // Create plane geometry with subdivisions for wave effect
            const flagGeometry = new THREE.PlaneGeometry(10, 6.67, 20, 15);

            // Create material
            const flagMaterial = new THREE.MeshStandardMaterial({
                map: flagTexture,
                side: THREE.DoubleSide,
                roughness: 0.7,
                metalness: 0.1
            });

            // Create mesh
            const flag = new THREE.Mesh(flagGeometry, flagMaterial);

            // Store original positions for animation
            const positions = flag.geometry.attributes.position;
            const originalPositions = new Float32Array(positions.array);

            return { flag, originalPositions };
        }

        // Update flag animation with Perlin noise
        function updateFlagAnimation() {
            if (!flagMesh || !flagOriginalPositions) return;

            flagTime = performance.now() * 0.001 * 3; // Speed factor

            const positions = flagMesh.geometry.attributes.position;
            const coeff = 72;
            const coeff2 = 65;
            const gap = 10;
            const spacing = 30;

            for (let i = 0; i < positions.count; i++) {
                const x = flagOriginalPositions[i * 3];
                const y = flagOriginalPositions[i * 3 + 1];

                // Apply Perlin noise to Z position for wave effect
                positions.array[i * 3 + 2] = 1 +
                    (spacing / 25) *
                    noise.perlin2(
                        x * (gap / coeff) + flagTime,
                        y * (gap / coeff2)
                    );
            }

            positions.needsUpdate = true;
            flagMesh.geometry.computeVertexNormals();

            // Render the flag scene
            flagRenderer.render(flagScene, flagCamera);
        }

        // Show waving flag
        function showWavingFlag(countryName) {
            // Try to get data from countryData first, fallback to legacy ISO mapping
            let data = countryData[countryName];
            let isoCode = data ? data.iso : countryToISO[countryName];

            if (!isoCode) {
                console.log('No ISO code found for:', countryName);
                // Still show the panel with limited info
                data = { iso: null, pop: 'N/A', area: 'N/A', lang: 'N/A' };
            }

            // Only create new flag if country changed
            if (currentHoveredCountry !== countryName) {
                currentHoveredCountry = countryName;

                // Remove old flag if exists
                if (flagMesh) {
                    flagScene.remove(flagMesh);
                    flagMesh.geometry.dispose();
                    flagMesh.material.dispose();
                }

                // Create new flag if ISO code exists
                if (isoCode) {
                    const { flag, originalPositions } = createWavingFlag(isoCode);
                    flagMesh = flag;
                    flagOriginalPositions = originalPositions;
                    flagScene.add(flagMesh);

                    // Reset time
                    flagTime = 0;
                }

                // Update country info
                document.querySelector('#flag-info .country-setText(name'), countryName);
                elements.get('info-population').textContent =
                    data && data.pop !== 'N/A' ? `${data.pop}M` : 'N/A';
                elements.get('info-area').textContent =
                    data && data.area !== 'N/A' ? data.area : 'N/A';
                elements.get('info-language').textContent =
                    data && data.lang !== 'N/A' ? data.lang : 'N/A';
            }

            // Show flag container (fixed position in top right)
            show(elements.get('flag-container'));
        }

        // Hide waving flag
        function hideWavingFlag() {
            hide(elements.get('flag-container'));
            currentHoveredCountry = null;
        }

        // Handle search input
        function onSearchInput(event) {
            const searchTerm = event.target.value.toLowerCase().trim();
            const resultsContainer = elements.get('search-results');

            // Reset search index when user types
            currentSearchIndex = -1;

            // Clear results if search is empty
            if (searchTerm === '') {
                resultsContainer.innerHTML = '';
                selectedSearchCountry = null; // Clear selection when search is empty
                return;
            }

            // Get unique country names from the countries array
            const uniqueCountryNames = [...new Set(countries.map(c => c.userData.name))];

            // Filter countries that match the search term
            const matchingCountries = uniqueCountryNames
                .filter(name => name.toLowerCase().includes(searchTerm))
                .sort();

            // Display results
            if (matchingCountries.length === 0) {
                resultsContainer.innerHTML = '<div style="color: #e0e0e0; padding: 8px;">No countries found</div>';
            } else {
                resultsContainer.innerHTML = matchingCountries
                    .map(name => `<div class="search-result-item" data-country="${name}">${name}</div>`)
                    .join('');

                // Add click handlers to results
                resultsContainer.querySelectorAll('.search-result-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const countryName = item.getAttribute('data-country');
                        selectCountryFromSearch(countryName);
                    });
                });
            }
        }

        // Handle Enter key and arrow keys in search
        function onSearchKeyDown(event) {
            const resultsContainer = elements.get('search-results');
            const resultItems = resultsContainer.querySelectorAll('.search-result-item');

            if (event.key === 'ArrowDown') {
                event.preventDefault();
                if (resultItems.length > 0) {
                    currentSearchIndex = (currentSearchIndex + 1) % resultItems.length;
                    updateSearchSelection(resultItems);
                }
            } else if (event.key === 'ArrowUp') {
                event.preventDefault();
                if (resultItems.length > 0) {
                    currentSearchIndex = currentSearchIndex <= 0 ? resultItems.length - 1 : currentSearchIndex - 1;
                    updateSearchSelection(resultItems);
                }
            } else if (event.key === 'Enter') {
                const searchTerm = event.target.value.trim();

                // Get unique country names
                const uniqueCountryNames = [...new Set(countries.map(c => c.userData.name))];

                // If user has navigated with arrow keys, use that selection
                let matchedCountry = null;
                if (currentSearchIndex >= 0 && currentSearchIndex < resultItems.length) {
                    matchedCountry = resultItems[currentSearchIndex].getAttribute('data-country');
                } else {
                    // Try exact match first (case insensitive)
                    matchedCountry = uniqueCountryNames.find(
                        name => name.toLowerCase() === searchTerm.toLowerCase()
                    );

                    // If no exact match, try partial match (take first result)
                    if (!matchedCountry) {
                        const matches = uniqueCountryNames
                            .filter(name => name.toLowerCase().includes(searchTerm.toLowerCase()))
                            .sort();
                        matchedCountry = matches[0];
                    }
                }

                if (matchedCountry) {
                    selectCountryFromSearch(matchedCountry);
                    // Select all text in the input
                    event.target.select();
                }
            }
        }

        // Update visual selection in search results
        function updateSearchSelection(resultItems) {
            resultItems.forEach((item, index) => {
                if (index === currentSearchIndex) {
                    item.style.backgroundColor = 'rgba(255, 140, 0, 0.2)';
                    item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                    // Update input value with selected country
                    elements.get('country-search').value = item.getAttribute('data-country');
                } else {
                    item.style.backgroundColor = '';
                }
            });
        }

        // Select country from search and hide results
        function selectCountryFromSearch(countryName) {
            selectedSearchCountry = countryName; // Track selected country
            focusOnCountryByName(countryName);
            // Hide search results after selection
            elements.get('search-results').innerHTML = '';
            currentSearchIndex = -1; // Reset search index

            // Reset the idle timer to give user 10 seconds before rotation resumes
            resetIdleTimer();
        }

        // Focus on country by name
        function focusOnCountryByName(countryName) {
            const country = countries.find(c => c.userData.name === countryName);
            if (country) {
                // Show the flag for this country
                showWavingFlag(countryName);

                // Highlight the country on the globe
                // Reset all countries first
                countries.forEach(c => {
                    c.material.vertexColors = true;
                    c.material.color.setHex(0xffffff);
                    c.material.needsUpdate = true;
                });

                // Highlight selected country
                country.material.vertexColors = false;
                country.material.color.setHex(0xFFFFFF);
                country.material.needsUpdate = true;

                // Rotate and tilt globe to center the country
                rotateGlobeToCountry(country);
            }
        }

        // Rotate globe to center a country
        function rotateGlobeToCountry(country, isQuizMode = false) {
            // Get the country's position (centroid of all vertices)
            const geometry = country.geometry;
            const positions = geometry.attributes.position;

            let centerX = 0, centerY = 0, centerZ = 0;
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;
            const vertexCount = positions.count;

            for (let i = 0; i < vertexCount; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                const z = positions.getZ(i);

                centerX += x;
                centerY += y;
                centerZ += z;

                // Track bounding box
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
                minZ = Math.min(minZ, z);
                maxZ = Math.max(maxZ, z);
            }

            centerX /= vertexCount;
            centerY /= vertexCount;
            centerZ /= vertexCount;

            // Calculate bounding box size (approximate land area)
            const bbox = new THREE.Vector3(maxX - minX, maxY - minY, maxZ - minZ);
            const bboxSize = bbox.length(); // Diagonal length of bounding box

            // Apply country's world matrix to get actual position
            const worldPos = new THREE.Vector3(centerX, centerY, centerZ);
            country.localToWorld(worldPos);

            // Normalize to get direction
            worldPos.normalize();

            // Calculate the spherical angles to this position
            let phi = Math.acos(worldPos.y); // Polar angle
            const theta = Math.atan2(worldPos.z, worldPos.x); // Azimuthal angle

            // Adjust phi to position camera lower during quiz mode only
            // This prevents the quiz container from obscuring the highlighted country
            if (isQuizMode) {
                phi = phi + 0.4; // Move camera down by ~23 degrees
            }

            // Calculate target camera distance
            let targetDistance;

            if (isQuizMode) {
                // Quiz mode: Use fixed distances to keep zoomed out
                if (bboxSize < 0.15) {
                    targetDistance = 2.0;
                } else if (bboxSize < 0.25) {
                    targetDistance = 2.5;
                } else if (bboxSize < 0.4) {
                    targetDistance = 3.0;
                } else {
                    targetDistance = Math.max(camera.position.length(), 3.5);
                }
            } else {
                // Normal mode: Calculate distance for country to occupy exactly 40% of screen width
                const fov = 75 * Math.PI / 180; // Camera FOV in radians
                const maxHorizontalDimension = Math.max(bbox.x, bbox.z); // Use horizontal dimensions
                const targetScreenPercentage = 0.4; // Country should occupy 40% of screen width

                // Calculate distance needed: d = size / (2 * tan(fov/2) * percentage)
                let calculatedDistance = maxHorizontalDimension / (2 * Math.tan(fov / 2) * targetScreenPercentage);

                // Apply multiplier to account for sphere curvature and ensure we're not too close
                // The bbox dimensions are chord lengths on the sphere, so we need to zoom out more
                calculatedDistance = calculatedDistance * 7.5;

                // Clamp to camera zoom limits (min: 1.13, max: 2)
                targetDistance = Math.max(1.13, Math.min(calculatedDistance, 2));
            }

            // Calculate target camera position
            const targetCameraPos = new THREE.Vector3(
                targetDistance * Math.sin(phi) * Math.cos(theta),
                targetDistance * Math.cos(phi),
                targetDistance * Math.sin(phi) * Math.sin(theta)
            );

            // Animate camera to new position
            const startPos = camera.position.clone();
            const startDist = startPos.length();
            const duration = 1000; // ms
            const startTime = Date.now();

            function animateRotation() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // Ease in-out cubic
                const easeProgress = progress < 0.5
                    ? 4 * progress * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 3) / 2;

                // Interpolate position
                const newPos = new THREE.Vector3().lerpVectors(startPos, targetCameraPos, easeProgress);

                // Interpolate distance as well for smooth zoom
                const newDist = startDist + (targetDistance - startDist) * easeProgress;
                newPos.setLength(newDist);

                camera.position.copy(newPos);
                camera.lookAt(0, 0, 0);
                controls.update();

                if (progress < 1) {
                    requestAnimationFrame(animateRotation);
                }
            }

            animateRotation();
        }

        // Update label visibility based on camera distance and orientation
        function updateLabelVisibility() {
            if (countryLabels.length === 0) return;

            // Hide all labels during quiz mode
            if (quizActive) {
                countryLabels.forEach(label => {
                    label.visible = false;
                });
                return;
            }

            // Calculate camera distance from globe center
            const cameraDistance = camera.position.length();

            // Define zoom thresholds (based on controls: min=1.5, max=10)
            const ZOOM_FAR = 6.0;    // Show only large countries
            const ZOOM_MEDIUM = 3.5; // Show large + medium countries
            const ZOOM_CLOSE = 2.2;  // Show all countries (large + medium + small)

            // Determine which size categories to show based on zoom
            let showLarge = false;
            let showMedium = false;
            let showSmall = false;

            if (cameraDistance >= ZOOM_FAR) {
                // Far zoom - show only large countries
                showLarge = true;
                showMedium = false;
                showSmall = false;
            } else if (cameraDistance >= ZOOM_MEDIUM) {
                // Medium zoom - show large and medium countries
                showLarge = true;
                showMedium = true;
                showSmall = false;
            } else {
                // Close zoom - show all countries
                showLarge = true;
                showMedium = true;
                showSmall = true;
            }

            // Get camera direction
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);

            // Update each label
            countryLabels.forEach(label => {
                // Use the pre-stored size category
                const sizeCategory = label.userData.sizeCategory;

                // Determine if this label should be shown based on zoom level
                let shouldShowByZoom = false;
                if (sizeCategory === 'large') {
                    shouldShowByZoom = showLarge;
                } else if (sizeCategory === 'medium') {
                    shouldShowByZoom = showMedium;
                } else if (sizeCategory === 'small') {
                    shouldShowByZoom = showSmall;
                }

                if (!shouldShowByZoom) {
                    label.visible = false;
                    return;
                }

                // Check if label is front-facing (visible from camera)
                const labelPosition = label.position.clone().normalize();
                const dotProduct = labelPosition.dot(cameraDirection);

                // Show label if it's facing the camera (dot product < 0, since camera looks inward)
                label.visible = dotProduct < -0.1; // Negative threshold - labels facing camera have negative dot product
            });
        }

        // Update border visibility based on camera distance
        function updateBorderVisibility() {
            if (countryBorders.length === 0) return;

            // Calculate camera distance from globe center
            const cameraDistance = camera.position.length();

            // Show borders when zoomed in (zoom range is 1.5-10)
            // Show borders at medium to close zoom levels
            const BORDER_THRESHOLD = 5.0;

            // Show borders when camera is closer than threshold
            const showBorders = cameraDistance < BORDER_THRESHOLD;

            // Update all border visibility
            countryBorders.forEach(border => {
                border.visible = showBorders;
            });
        }

        // Update zoom widget display
        function updateZoomWidget() {
            const MIN_ZOOM = 1.13;
            const MAX_ZOOM = 10;

            // Get current camera distance
            const currentZoom = camera.position.length();

            // Clamp value
            const clampedZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, currentZoom));

            // Calculate percentage (inverted - closer = higher bar)
            const percentage = ((MAX_ZOOM - clampedZoom) / (MAX_ZOOM - MIN_ZOOM)) * 100;

            // Update bar fill height
            const zoomBarFill = elements.get('zoom-bar-fill');
            if (zoomBarFill) {
                zoomBarFill.style.height = percentage + '%';
            }

            // Update text value
            const zoomValue = elements.get('zoom-value');
            if (zoomValue) {
                setText(zoomValue, clampedZoom.toFixed(2));
            }
        }

        // Update search container visibility on mobile based on zoom level
        function updateSearchVisibilityOnMobile() {
            // Only apply on mobile devices
            const isMobile = window.innerWidth <= 768;
            if (!isMobile) return;

            const searchContainer = elements.get('search-container');
            if (!searchContainer) return;

            // Get current camera distance
            const currentZoom = camera.position.length();

            // Hide search when zoomed in (closer than 3.5), show when zoomed out
            if (currentZoom < 3.5) {
                hide(searchContainer);
            } else {
                show(searchContainer);
            }
        }

        // Update zoom out button visibility based on zoom level
        function updateZoomOutButtonVisibility() {
            const zoomOutBtn = elements.get('zoom-out-btn');
            if (!zoomOutBtn) return;

            // Get current camera distance
            const currentZoom = camera.position.length();

            // Show button when zoomed in (closer than 4), hide when zoomed out
            if (currentZoom < 4) {
                show(zoomOutBtn);
            } else {
                hide(zoomOutBtn);
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            // Update controls (required for damping)
            controls.update();

            // Update light position to stay behind camera
            if (scene.userData.cameraLight) {
                scene.userData.cameraLight.position.copy(camera.position);
            }

            // Update flag animation if visible
            if (currentHoveredCountry) {
                updateFlagAnimation();
            }

            // Update flag quiz animation if active
            if (flagQuizMesh && flagQuizRenderer) {
                updateFlagQuizAnimation();
                flagQuizRenderer.render(flagQuizScene, flagQuizCamera);
            }

            // Update country label visibility based on zoom level
            updateLabelVisibility();

            // Update country border visibility based on zoom level
            // updateBorderVisibility(); // Disabled for performance

            // Update zoom widget
            updateZoomWidget();

            // Update search visibility on mobile based on zoom
            updateSearchVisibilityOnMobile();

            // Update zoom out button visibility based on zoom
            updateZoomOutButtonVisibility();

            // Render
            renderer.render(scene, camera);
        }

        // Start the application
        init();
    </script>
</body>
</html>