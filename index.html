<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Interactive 3D world globe with 195+ countries. Explore geography, take quizzes, and learn about the world with this free educational WebGL map powered by Three.js.">
    <meta name="keywords" content="3D world map, interactive globe, geography quiz, world atlas, educational map, Three.js globe, WebGL earth, geography learning">
    <title>Interactive 3D World Globe Map | Free Geography Quiz & Educational Tool</title>
    <link rel="stylesheet" href="styles.css">
    <!-- Confetti Library -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
    <!-- Eruda Mobile DevTools (temporary for debugging) -->
    <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
    <script>eruda.init();</script>
</head>
<body>
    <!-- SEO Content Overlay -->
    <div id="seo-content">
        <div id="seo-text-wrapper">
            <h1>Interactive 3D World Globe</h1>
            <p>Explore our interactive 3D globe featuring all 195 countries of the world. Click, drag, and zoom to discover geography in an immersive way.</p>

            <h2>Features</h2>
            <ul>
                <li>Interactive 3D visualization of all countries</li>
                <li>Geography quizzes to test your knowledge</li>
                <li>Country information including flags, population, and area</li>
                <li>Smooth rotation and zoom controls</li>
                <li>Educational tool for learning world geography</li>
            </ul>

            <p><strong>Wait for the globe to load, then click the start button below!</strong></p>
        </div>

        <!-- Loading Progress Bar and Start Button -->
        <div id="loading-progress-container">
            <div id="loading-progress-bar">
                <div id="loading-progress-fill"></div>
                <div id="loading-progress-text">Loading... 0%</div>
            </div>
            <button id="start-button" style="display: none;">Start Exploring</button>
        </div>
    </div>

    <div id="container">
        <button id="zoom-out-btn">üåç Zoom Out</button>
        <div id="loading">Loading world map data...</div>
        <button id="take-quiz-btn">Take Quiz</button>
        <button id="edit-mode-btn">Edit Labels</button>
        <button id="save-config-btn" style="display: none;">Save Config</button>
        <button id="fine-tune-btn" style="display: none;">Fine Tune</button>
        <button id="edit-colors-btn">Edit Colors</button>
        <button id="save-colors-btn" style="display: none;">Save Colors</button>

        <!-- Zoom Level Widget -->
        <div id="zoom-widget">
            <div id="zoom-label-top">Zoom</div>
            <div id="zoom-bar-container">
                <div id="zoom-bar-fill"></div>
            </div>
            <div id="zoom-value">2.5</div>
        </div>

        <div id="flag-container">
            <div id="flag-container-content">
                <div id="flag-info">
                    <div class="country-name"></div>
                    <div class="info-item"><span class="info-label">Population:</span> <span id="info-population"></span></div>
                    <div class="info-item"><span class="info-label">Area:</span> <span id="info-area"></span></div>
                    <div class="info-item"><span class="info-label">Language:</span> <span id="info-language"></span></div>
                </div>
            </div>
        </div>
        <div id="search-container">
            <div id="search-box">
                <span id="search-icon">üîç</span>
                <input type="text" id="country-search" placeholder="Search countries...">
            </div>
            <div id="search-results"></div>
        </div>
        <div id="controls">
            <div class="control-item">
                <strong>Controls:</strong>
            </div>
            <div class="control-item">
                ‚Ä¢ Drag to rotate
            </div>
            <div class="control-item">
                ‚Ä¢ Scroll to zoom
            </div>
            <div class="control-item" style="margin-top: 15px;">
                <strong>Inner Sphere Radius:</strong>
            </div>
            <div class="control-item">
                <span id="sphere-radius-value">1.014</span>
                <button id="sphere-radius-down" style="margin-left: 10px; padding: 2px 8px;">‚ñº</button>
                <button id="sphere-radius-up" style="padding: 2px 8px;">‚ñ≤</button>
            </div>
            <div class="control-item">
                <label for="sphere-toggle" style="width: auto;">
                    <input type="checkbox" id="sphere-toggle" checked style="width: auto; margin-right: 5px;">
                    Show Inner Sphere
                </label>
            </div>
        </div>
        <div id="quiz-container">
            <div id="quiz-header">Geography Quiz</div>
            <div id="quiz-score" style="display: none;">Score: <span id="quiz-score-value">0</span> / <span id="quiz-total-value">0</span></div>
            <div id="quiz-question" style="display: none;">Which country is highlighted?</div>
            <div id="quiz-flag-display" style="display: none;">
                <!-- Flag will be rendered here -->
            </div>
            <div id="quiz-options">
                <!-- Options will be dynamically inserted here -->
            </div>
            <div id="quiz-result"></div>
            <button id="quiz-start-btn">Start Quiz</button>
            <button id="quiz-next-btn" style="visibility: hidden;">Next Question</button>
            <button id="quiz-cancel-btn" style="display: none;" title="Cancel Quiz">√ó</button>
        </div>

        <!-- Quiz Celebration Overlay -->
        <div id="quiz-celebration-overlay" style="display: none;">
            <div id="quiz-celebration-content">
                <h1 id="celebration-title">üéâ Congratulations! üéâ</h1>
                <p id="celebration-message">Quiz Complete!</p>
                <div id="celebration-score"></div>
                <button id="celebration-close-btn">Play Again</button>
            </div>
        </div>

        <!-- Quiz Mode Selector Modal -->
        <div id="quiz-mode-selector" style="display: none;">
            <div id="quiz-mode-overlay"></div>
            <div id="quiz-mode-content">
                <h2>Choose Quiz Mode</h2>
                <div id="quiz-mode-options">
                    <button class="quiz-mode-option" id="name-flag-quiz-btn">
                        <h3>Name the Country</h3>
                        <p>See a highlighted country on the globe and select its flag from the options</p>
                    </button>
                    <button class="quiz-mode-option" id="identify-flag-quiz-btn">
                        <h3>Identify the Flag</h3>
                        <p>Look at the flag and choose which country it belongs to</p>
                    </button>
                    <button class="quiz-mode-option" id="find-country-quiz-btn">
                        <h3>Find the Country</h3>
                        <p>Click on the correct country when given its name - 10 questions in 45 seconds!</p>
                    </button>
                </div>
                <button id="quiz-mode-close">Cancel</button>
            </div>
        </div>

        <!-- Click Quiz UI -->
        <div id="click-quiz-container" style="display: none;">
            <div id="click-quiz-header">
                <div id="click-quiz-country-name"></div>
                <div id="click-quiz-info">
                    <span id="click-quiz-question-counter"></span>
                    <span id="click-quiz-score-display"></span>
                </div>
            </div>
            <div id="click-quiz-feedback"></div>
            <button id="click-quiz-cancel-btn" title="Cancel Quiz">√ó</button>
        </div>

        <!-- Click Quiz Timer Bar -->
        <div id="click-quiz-timer-bar-container" style="display: none;">
            <div id="click-quiz-timer-fill"></div>
        </div>

        <!-- Click Quiz Results Modal -->
        <div id="click-quiz-results" style="display: none;">
            <div id="click-quiz-results-overlay"></div>
            <div id="click-quiz-results-content">
                <h2>Quiz Complete!</h2>
                <div id="click-quiz-final-score"></div>
                <div id="click-quiz-final-time"></div>
                <button id="click-quiz-close-btn">Close</button>
            </div>
        </div>

        <!-- Label Editor Modal -->
        <div id="label-editor-modal" style="display: none;">
            <div id="label-editor-overlay"></div>
            <div id="label-editor-content">
                <h2 id="label-editor-title">Edit Label</h2>
                <div class="label-editor-section">
                    <label>Position Offset X:</label>
                    <input type="range" id="label-offset-x" min="-0.2" max="0.2" step="0.01" value="0">
                    <span id="label-offset-x-value">0.00</span>
                </div>
                <div class="label-editor-section">
                    <label>Position Offset Y:</label>
                    <input type="range" id="label-offset-y" min="-0.2" max="0.2" step="0.01" value="0">
                    <span id="label-offset-y-value">0.00</span>
                </div>
                <div class="label-editor-section">
                    <label>Position Offset Z:</label>
                    <input type="range" id="label-offset-z" min="-0.2" max="0.2" step="0.01" value="0">
                    <span id="label-offset-z-value">0.00</span>
                </div>
                <div class="label-editor-section">
                    <label>Scale:</label>
                    <input type="range" id="label-scale" min="0.1" max="3.0" step="0.1" value="1.0">
                    <span id="label-scale-value">1.0</span>
                </div>
                <div class="label-editor-buttons">
                    <button id="label-reset-btn">Reset to Default</button>
                    <button id="label-editor-close-btn">Close</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/perlin.js/1.0/perlin.js"></script>
    <script type="module">
        // ===== IMPORTS =====
        import { state } from './js/data/state.js';
        import { SceneManager } from './js/core/scene.js';
        import { GlobeManager } from './js/core/globe.js';
        import { LabelManager } from './js/core/labels.js';
        import { CameraController } from './js/core/camera-controls.js';
        import { QuizManager } from './js/features/quiz/quiz-manager.js';
        import { NameFlagQuiz } from './js/features/quiz/name-flag-quiz.js';
        import { IdentifyFlagQuiz } from './js/features/quiz/identify-flag-quiz.js';
        import { ClickQuiz } from './js/features/quiz/click-quiz.js';
        import { FlagRenderer } from './js/features/flag-renderer.js';
        import { SearchManager } from './js/features/search.js';
        import { LabelEditor } from './js/features/label-editor.js';

        // ===== DOM UTILITIES (inline for compatibility) =====
        class ElementCache {
            constructor() {
                this.cache = new Map();
            }
            get(id) {
                if (!this.cache.has(id)) {
                    const element = document.getElementById(id);
                    if (element) {
                        this.cache.set(id, element);
                    }
                    return element;
                }
                return this.cache.get(id);
            }
        }

        const elements = new ElementCache();

        function show(element) {
            if (element) element.style.display = 'block';
        }

        function hide(element) {
            if (element) element.style.display = 'none';
        }

        function showFlex(element) {
            if (element) element.style.display = 'flex';
        }

        function setText(element, text) {
            if (element) element.textContent = text;
        }

        function addClass(element, className) {
            if (element && className) element.classList.add(className);
        }

        function removeClass(element, className) {
            if (element && className) element.classList.remove(className);
        }

        function toggleClass(element, className) {
            if (element && className) element.classList.toggle(className);
        }

        // ===== FLAG ANIMATION UTILITY (unified to avoid duplication) =====
        /**
         * Unified flag waving animation using Perlin noise
         * @param {Object} mesh - The flag mesh to animate
         * @param {Float32Array} originalPositions - Original vertex positions
         * @param {number} time - Current animation time
         */
        function animateFlagWave(mesh, originalPositions, time) {
            if (!mesh || !originalPositions) return;

            const positions = mesh.geometry.attributes.position;
            const coeff = 72;
            const coeff2 = 65;
            const gap = 10;
            const spacing = 30;

            for (let i = 0; i < positions.count; i++) {
                const x = originalPositions[i * 3];
                const y = originalPositions[i * 3 + 1];

                // Apply Perlin noise to Z position for wave effect
                positions.array[i * 3 + 2] = 1 +
                    (spacing / 25) *
                    noise.perlin2(
                        x * (gap / coeff) + time,
                        y * (gap / coeff2)
                    );
            }

            positions.needsUpdate = true;
            mesh.geometry.computeVertexNormals();
        }

        // ===== QUIZ UTILITIES (unified to reduce duplication) =====
        /**
         * Show quiz celebration overlay with score
         * @param {number} score - Number of correct answers
         * @param {number} total - Total number of questions
         * @param {string} extraInfo - Optional extra info to display (e.g., time)
         */
        function showQuizCelebration(score, total, extraInfo = '') {
            const percentage = Math.round((score / total) * 100);
            const extraHTML = extraInfo ? `<div style="font-size: 1.2rem; margin-top: 15px; color: #E0E0E0;">${extraInfo}</div>` : '';

            elements.get('celebration-score').innerHTML = `
                <div style="font-size: 1.5rem; margin-bottom: 10px;">Your Score</div>
                <div>${score} / ${total}</div>
                <div style="font-size: 2rem; margin-top: 10px;">${percentage}%</div>
                ${extraHTML}
            `;

            const overlay = elements.get('quiz-celebration-overlay');
            showFlex(overlay);
            triggerConfetti();
        }

        /**
         * Clear quiz timers (auto-advance, click quiz, etc.)
         * @param {number|null} autoAdvanceTimer - Auto-advance timer ID
         * @param {number|null} clickQuizTimer - Click quiz interval ID
         * @returns {Object} - Object with cleared timer values
         */
        function clearQuizTimers(autoAdvanceTimer = null, clickQuizTimer = null) {
            if (autoAdvanceTimer) {
                clearTimeout(autoAdvanceTimer);
            }
            if (clickQuizTimer) {
                clearInterval(clickQuizTimer);
            }
            return { autoAdvanceTimer: null, clickQuizTimer: null };
        }

        // Perlin noise library (inline for self-containment)
        // NOTE: Changed (this) to (window) for ES6 module compatibility
        (function(global){var module=global.noise={};function Grad(x,y,z){this.x=x;this.y=y;this.z=z}Grad.prototype.dot2=function(x,y){return this.x*x+this.y*y};Grad.prototype.dot3=function(x,y,z){return this.x*x+this.y*y+this.z*z};var grad3=[new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)];var p=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];var perm=new Array(512);var gradP=new Array(512);module.seed=function(seed){if(seed>0&&seed<1){seed*=65536}seed=Math.floor(seed);if(seed<256){seed|=seed<<8}for(var i=0;i<256;i++){var v;if(i&1){v=p[i]^(seed&255)}else{v=p[i]^((seed>>8)&255)}perm[i]=perm[i+256]=v;gradP[i]=gradP[i+256]=grad3[v%12]}};module.seed(0);function fade(t){return t*t*t*(t*(t*6-15)+10)}function lerp(a,b,t){return(1-t)*a+t*b}module.perlin2=function(x,y){var X=Math.floor(x),Y=Math.floor(y);x=x-X;y=y-Y;X=X&255;Y=Y&255;var n00=gradP[X+perm[Y]].dot2(x,y);var n01=gradP[X+perm[Y+1]].dot2(x,y-1);var n10=gradP[X+1+perm[Y]].dot2(x-1,y);var n11=gradP[X+1+perm[Y+1]].dot2(x-1,y-1);var u=fade(x);return lerp(lerp(n00,n10,u),lerp(n01,n11,u),fade(y))}})(window);

        // Global variables
        let scene, camera, renderer, globe, countries = [];
        let mouse = new THREE.Vector2();
        let raycaster = new THREE.Raycaster();
        let selectedCountry = null;
        let smallCountryIndicator = null; // White circle indicator for tiny countries
        let controls;
        let baseSphere;
        let mouseDownPos = new THREE.Vector2();
        let isDragging = false;
        let initialCameraDistance; // Store initial camera distance for zoom out

        // SEO content visibility
        let seoContentHidden = false;

        // Quiz variables
        let countryCentroids = []; // Array of { name, centroid: Vector3, meshRef }
        let quizActive = false;
        let currentQuizMode = null; // 'name-flag', 'identify-flag', or 'find-country'
        let currentQuizQuestion = null; // { correctCountry, options: [country names] }
        let quizScore = 0;
        let quizQuestionsAnswered = 0;
        let usedQuizCountries = []; // Track countries already used in current quiz
        let quizAutoAdvanceTimer = null; // Timer for auto-advancing to next question

        // Click quiz variables
        let clickQuizActive = false;
        let clickQuizCountries = []; // Array of 10 country names for this quiz
        let clickQuizCurrentIndex = 0; // Current question (0-9)
        let clickQuizScore = 0; // Number of correct answers
        let clickQuizStartTime = 0; // Timestamp when quiz started
        let clickQuizTimeRemaining = 45000; // Milliseconds remaining (45 seconds)
        let clickQuizTimerInterval = null; // Interval ID for timer updates

        // Country labels
        let countryLabels = []; // Array of label meshes

        // Color edit mode variables
        let colorEditMode = false;
        let colorConfig = {}; // Stores custom country colors

        // Curated color palette (10 distinct colors in darker tones for lighting)
        const COLOR_PALETTE = [
            [0.2, 0.5, 0.25],   // Forest Green
            [0.45, 0.45, 0.15], // Olive/Yellow-Green
            [0.5, 0.35, 0.15],  // Orange/Rust
            [0.35, 0.2, 0.45],  // Purple/Violet
            [0.2, 0.45, 0.45],  // Teal/Cyan
            [0.4, 0.3, 0.2],    // Brown/Earth
            [0.5, 0.45, 0.2],   // Dark Yellow/Gold
            [0.45, 0.25, 0.35], // Magenta/Deep Pink
            [0.2, 0.25, 0.4],   // Navy/Dark Blue
            [0.4, 0.2, 0.25]    // Burgundy/Wine Red
        ];

        // Country size categories for label sizing and visibility
        const LARGE_COUNTRIES = new Set([
            'Russia', 'Canada', 'United States', 'China', 'Brazil', 'Australia',
            'India', 'Argentina', 'Kazakhstan', 'Algeria', 'Democratic Republic Of The Congo',
            'Saudi Arabia', 'Mexico', 'Indonesia', 'Libya', 'Iran', 'Mongolia',
            'Peru', 'Chad', 'Niger', 'Angola', 'Mali', 'South Africa', 'Colombia',
            'Ethiopia', 'Bolivia', 'Mauritania', 'Egypt', 'Tanzania', 'Nigeria',
            'Venezuela', 'Pakistan', 'Mozambique', 'Turkey', 'Chile', 'Zambia',
            'Myanmar', 'Afghanistan', 'Somalia', 'Central African Republic', 'Ukraine',
            'Madagascar', 'Botswana', 'Kenya', 'France', 'Yemen', 'Thailand',
            'Spain', 'Turkmenistan', 'Cameroon', 'Papua New Guinea', 'Sweden',
            'Uzbekistan', 'Morocco', 'Iraq', 'Paraguay', 'Zimbabwe'
        ]);

        const SMALL_COUNTRIES = new Set([
            'Singapore', 'Bahrain', 'Malta', 'Maldives', 'Barbados',
            'Saint Lucia', 'Antigua And Barbuda', 'Andorra', 'Seychelles',
            'Palau', 'Saint Vincent And The Grenadines', 'Grenada',
            'Saint Kitts And Nevis', 'Marshall Islands', 'Liechtenstein',
            'San Marino', 'Tuvalu', 'Nauru', 'Monaco', 'Vatican City',
            'Comoros', 'Mauritius', 'Sao Tome And Principe', 'Dominica',
            'Tonga', 'Kiribati', 'Micronesia', 'Cape Verde', 'Samoa'
        ]);

        // Country borders
        let countryBorders = []; // Array of border line segments

        // Auto-rotation state
        let autoRotateEnabled = false;
        let lastInteractionTime = Date.now();
        let idleTimeout = null;
        const IDLE_DELAY = 60000; // 1 minute

        // ===== CORE MANAGERS (initialized in init()) =====
        let sceneManager = null;
        let globeManager = null;
        let labelManager = null;
        let cameraController = null;
        let quizManager = null;
        let nameFlagQuiz = null;
        let identifyFlagQuiz = null;
        let clickQuiz = null;
        let flagRenderer = null;
        let searchManager = null;
        let labelEditor = null;

        // ===== STATE SYNCHRONIZATION =====
        // Initialize state manager with current variable values
        // This allows gradual migration to centralized state
        function syncStateWithVariables() {
            // Sync scene objects (if they exist)
            if (scene) state.set('scene.scene', scene, false);
            if (camera) state.set('scene.camera', camera, false);
            if (renderer) state.set('scene.renderer', renderer, false);
            if (globe) state.set('scene.globe', globe, false);
            if (controls) state.set('scene.controls', controls, false);
            if (baseSphere) state.set('scene.baseSphere', baseSphere, false);
            if (initialCameraDistance !== undefined) {
                state.set('scene.initialCameraDistance', initialCameraDistance, false);
            }

            // Sync countries and mouse objects
            state.set('countries.list', countries, false);
            state.set('countries.centroids', countryCentroids, false);
            state.set('countries.selected', selectedCountry, false);
            state.set('countries.borders', countryBorders, false);
            if (mouse) state.set('mouse.position', mouse, false);
            if (raycaster) state.set('mouse.raycaster', raycaster, false);
            if (mouseDownPos) state.set('mouse.downPos', mouseDownPos, false);
            state.set('mouse.isDragging', isDragging, false);

            // Sync flag renderer
            if (flagRenderer) {
                state.set('flags.renderer', flagRenderer, false);
            }

            // Sync search manager
            if (searchManager) {
                state.set('search.manager', searchManager, false);
            }

            // Sync UI state
            state.set('ui.seoContentHidden', seoContentHidden, false);

            // Sync quiz state
            state.set('quiz.active', quizActive, false);
            state.set('quiz.mode', currentQuizMode, false);
            state.set('quiz.currentQuestion', currentQuizQuestion, false);
            state.set('quiz.score', quizScore, false);
            state.set('quiz.questionsAnswered', quizQuestionsAnswered, false);
            state.set('quiz.usedCountries', usedQuizCountries, false);
            state.set('quiz.autoAdvanceTimer', quizAutoAdvanceTimer, false);

            // Sync click quiz state
            state.set('quiz.clickQuiz.active', clickQuizActive, false);
            state.set('quiz.clickQuiz.countries', clickQuizCountries, false);
            state.set('quiz.clickQuiz.currentIndex', clickQuizCurrentIndex, false);
            state.set('quiz.clickQuiz.score', clickQuizScore, false);
            state.set('quiz.clickQuiz.startTime', clickQuizStartTime, false);
            state.set('quiz.clickQuiz.timeRemaining', clickQuizTimeRemaining, false);
            state.set('quiz.clickQuiz.timerInterval', clickQuizTimerInterval, false);

            // Sync label state
            state.set('labels.list', countryLabels, false);
            if (labelEditor) {
                state.set('labels.config', labelEditor.getConfig(), false);
                state.set('labels.defaults', labelEditor.getDefaults(), false);
                state.set('labels.editMode', labelEditor.isActive(), false);
                state.set('labels.isDragging', labelEditor.isDragging(), false);
            }

            // Sync color editor state
            state.set('colorEditor.editMode', colorEditMode, false);
            state.set('colorEditor.config', colorConfig, false);

            // Sync auto-rotation state
            state.set('autoRotation.enabled', autoRotateEnabled, false);
            state.set('autoRotation.lastInteractionTime', lastInteractionTime, false);
            state.set('autoRotation.idleTimer', idleTimeout, false);
        }

        // Country data: ISO code, population (millions), area (km¬≤), primary language
        const countryData = {
            'United States': { iso: 'us', pop: 331.9, area: '9.8M km¬≤', lang: 'English' },
            'Canada': { iso: 'ca', pop: 38.2, area: '9.9M km¬≤', lang: 'English, French' },
            'Mexico': { iso: 'mx', pop: 126.7, area: '1.9M km¬≤', lang: 'Spanish' },
            'Brazil': { iso: 'br', pop: 214.3, area: '8.5M km¬≤', lang: 'Portuguese' },
            'Argentina': { iso: 'ar', pop: 45.8, area: '2.8M km¬≤', lang: 'Spanish' },
            'Chile': { iso: 'cl', pop: 19.5, area: '756K km¬≤', lang: 'Spanish' },
            'Peru': { iso: 'pe', pop: 33.7, area: '1.3M km¬≤', lang: 'Spanish' },
            'Colombia': { iso: 'co', pop: 51.5, area: '1.1M km¬≤', lang: 'Spanish' },
            'Venezuela': { iso: 've', pop: 28.2, area: '916K km¬≤', lang: 'Spanish' },
            'United Kingdom': { iso: 'gb', pop: 67.3, area: '243K km¬≤', lang: 'English' },
            'France': { iso: 'fr', pop: 67.7, area: '643K km¬≤', lang: 'French' },
            'Germany': { iso: 'de', pop: 83.2, area: '357K km¬≤', lang: 'German' },
            'Italy': { iso: 'it', pop: 59.1, area: '301K km¬≤', lang: 'Italian' },
            'Spain': { iso: 'es', pop: 47.4, area: '506K km¬≤', lang: 'Spanish' },
            'Portugal': { iso: 'pt', pop: 10.3, area: '92K km¬≤', lang: 'Portuguese' },
            'Netherlands': { iso: 'nl', pop: 17.5, area: '42K km¬≤', lang: 'Dutch' },
            'Belgium': { iso: 'be', pop: 11.6, area: '31K km¬≤', lang: 'Dutch, French' },
            'Switzerland': { iso: 'ch', pop: 8.7, area: '41K km¬≤', lang: 'German, French' },
            'Austria': { iso: 'at', pop: 9.0, area: '84K km¬≤', lang: 'German' },
            'Poland': { iso: 'pl', pop: 38.0, area: '313K km¬≤', lang: 'Polish' },
            'Czech Republic': { iso: 'cz', pop: 10.5, area: '79K km¬≤', lang: 'Czech' },
            'Czechia': { iso: 'cz', pop: 10.5, area: '79K km¬≤', lang: 'Czech' },
            'Hungary': { iso: 'hu', pop: 9.7, area: '93K km¬≤', lang: 'Hungarian' },
            'Romania': { iso: 'ro', pop: 19.0, area: '238K km¬≤', lang: 'Romanian' },
            'Greece': { iso: 'gr', pop: 10.6, area: '132K km¬≤', lang: 'Greek' },
            'Turkey': { iso: 'tr', pop: 85.3, area: '784K km¬≤', lang: 'Turkish' },
            'Ukraine': { iso: 'ua', pop: 43.8, area: '604K km¬≤', lang: 'Ukrainian' },
            'Russia': { iso: 'ru', pop: 144.1, area: '17.1M km¬≤', lang: 'Russian' },
            'China': { iso: 'cn', pop: 1412.0, area: '9.6M km¬≤', lang: 'Mandarin' },
            'Japan': { iso: 'jp', pop: 125.7, area: '378K km¬≤', lang: 'Japanese' },
            'South Korea': { iso: 'kr', pop: 51.8, area: '100K km¬≤', lang: 'Korean' },
            'India': { iso: 'in', pop: 1408.0, area: '3.3M km¬≤', lang: 'Hindi, English' },
            'Pakistan': { iso: 'pk', pop: 229.5, area: '881K km¬≤', lang: 'Urdu' },
            'Bangladesh': { iso: 'bd', pop: 169.4, area: '148K km¬≤', lang: 'Bengali' },
            'Indonesia': { iso: 'id', pop: 275.5, area: '1.9M km¬≤', lang: 'Indonesian' },
            'Thailand': { iso: 'th', pop: 70.0, area: '513K km¬≤', lang: 'Thai' },
            'Vietnam': { iso: 'vn', pop: 98.2, area: '331K km¬≤', lang: 'Vietnamese' },
            'Philippines': { iso: 'ph', pop: 113.9, area: '300K km¬≤', lang: 'Filipino' },
            'Malaysia': { iso: 'my', pop: 33.2, area: '330K km¬≤', lang: 'Malay' },
            'Singapore': { iso: 'sg', pop: 5.9, area: '728 km¬≤', lang: 'English' },
            'Australia': { iso: 'au', pop: 25.9, area: '7.7M km¬≤', lang: 'English' },
            'New Zealand': { iso: 'nz', pop: 5.1, area: '268K km¬≤', lang: 'English' },
            'Egypt': { iso: 'eg', pop: 106.2, area: '1.0M km¬≤', lang: 'Arabic' },
            'South Africa': { iso: 'za', pop: 60.6, area: '1.2M km¬≤', lang: 'English, Afrikaans' },
            'Nigeria': { iso: 'ng', pop: 216.7, area: '924K km¬≤', lang: 'English' },
            'Kenya': { iso: 'ke', pop: 54.0, area: '580K km¬≤', lang: 'Swahili' },
            'Ethiopia': { iso: 'et', pop: 120.8, area: '1.1M km¬≤', lang: 'Amharic' },
            'Saudi Arabia': { iso: 'sa', pop: 35.9, area: '2.1M km¬≤', lang: 'Arabic' },
            'Iran': { iso: 'ir', pop: 87.9, area: '1.6M km¬≤', lang: 'Persian' },
            'Iraq': { iso: 'iq', pop: 42.2, area: '438K km¬≤', lang: 'Arabic' },
            'Israel': { iso: 'il', pop: 9.4, area: '22K km¬≤', lang: 'Hebrew' },
            'Norway': { iso: 'no', pop: 5.5, area: '385K km¬≤', lang: 'Norwegian' },
            'Sweden': { iso: 'se', pop: 10.4, area: '447K km¬≤', lang: 'Swedish' },
            'Finland': { iso: 'fi', pop: 5.5, area: '338K km¬≤', lang: 'Finnish' },
            'Denmark': { iso: 'dk', pop: 5.9, area: '43K km¬≤', lang: 'Danish' },
            'Ireland': { iso: 'ie', pop: 5.0, area: '70K km¬≤', lang: 'English' },
            'Iceland': { iso: 'is', pop: 0.4, area: '103K km¬≤', lang: 'Icelandic' },
            'Afghanistan': { iso: 'af', pop: 43.0, area: '653K km¬≤', lang: 'Pashto, Dari' },
            'Albania': { iso: 'al', pop: 2.4, area: '29K km¬≤', lang: 'Albanian' },
            'Algeria': { iso: 'dz', pop: 47.0, area: '2.4M km¬≤', lang: 'Arabic, Berber' },
            'Angola': { iso: 'ao', pop: 39.0, area: '1.2M km¬≤', lang: 'Portuguese' },
            'Armenia': { iso: 'am', pop: 3.1, area: '30K km¬≤', lang: 'Armenian' },
            'Azerbaijan': { iso: 'az', pop: 10.4, area: '87K km¬≤', lang: 'Azerbaijani' },
            'Bahrain': { iso: 'bh', pop: 1.5, area: '787 km¬≤', lang: 'Arabic' },
            'Belarus': { iso: 'by', pop: 9.1, area: '208K km¬≤', lang: 'Belarusian, Russian' },
            'Belize': { iso: 'bz', pop: 0.4, area: '23K km¬≤', lang: 'English' },
            'Benin': { iso: 'bj', pop: 13.0, area: '115K km¬≤', lang: 'French' },
            'Bhutan': { iso: 'bt', pop: 0.7, area: '38K km¬≤', lang: 'Dzongkha' },
            'Bolivia': { iso: 'bo', pop: 11.4, area: '1.1M km¬≤', lang: 'Spanish' },
            'Bosnia And Herzegovina': { iso: 'ba', pop: 2.9, area: '51K km¬≤', lang: 'Bosnian, Croatian, Serbian' },
            'Botswana': { iso: 'bw', pop: 2.4, area: '582K km¬≤', lang: 'English, Tswana' },
            'Brunei': { iso: 'bn', pop: 0.5, area: '5.8K km¬≤', lang: 'Malay' },
            'Bulgaria': { iso: 'bg', pop: 6.5, area: '111K km¬≤', lang: 'Bulgarian' },
            'Burkina Faso': { iso: 'bf', pop: 22.5, area: '274K km¬≤', lang: 'French' },
            'Burundi': { iso: 'bi', pop: 14.2, area: '28K km¬≤', lang: 'Kirundi, French, English' },
            'Cambodia': { iso: 'kh', pop: 17.6, area: '181K km¬≤', lang: 'Khmer' },
            'Cameroon': { iso: 'cm', pop: 31.0, area: '475K km¬≤', lang: 'English, French' },
            'Cape Verde': { iso: 'cv', pop: 0.6, area: '4K km¬≤', lang: 'Portuguese' },
            'Central African Republic': { iso: 'cf', pop: 5.4, area: '623K km¬≤', lang: 'French, Sango' },
            'Chad': { iso: 'td', pop: 19.1, area: '1.3M km¬≤', lang: 'Arabic, French' },
            'Comoros': { iso: 'km', pop: 0.9, area: '2K km¬≤', lang: 'Comorian, French, Arabic' },
            'Congo': { iso: 'cg', pop: 6.2, area: '342K km¬≤', lang: 'French' },
            'Costa Rica': { iso: 'cr', pop: 5.0, area: '51K km¬≤', lang: 'Spanish' },
            'Croatia': { iso: 'hr', pop: 3.9, area: '57K km¬≤', lang: 'Croatian' },
            'Cuba': { iso: 'cu', pop: 11.0, area: '111K km¬≤', lang: 'Spanish' },
            'Cyprus': { iso: 'cy', pop: 0.9, area: '9.3K km¬≤', lang: 'Greek, Turkish' },
            'Dem Rep Of Congo': { iso: 'cd', pop: 112.0, area: '2.3M km¬≤', lang: 'French' },
            'Djibouti': { iso: 'dj', pop: 1.1, area: '23K km¬≤', lang: 'Arabic, French' },
            'Dominican Republic': { iso: 'do', pop: 11.4, area: '49K km¬≤', lang: 'Spanish' },
            'Ecuador': { iso: 'ec', pop: 17.5, area: '284K km¬≤', lang: 'Spanish' },
            'Equatorial Guinea': { iso: 'gq', pop: 1.8, area: '28K km¬≤', lang: 'Spanish, French, Portuguese' },
            'Eritrea': { iso: 'er', pop: 5.0, area: '120K km¬≤', lang: 'Tigrinya' },
            'Estonia': { iso: 'ee', pop: 1.4, area: '45K km¬≤', lang: 'Estonian' },
            'Fiji': { iso: 'fj', pop: 0.9, area: '18K km¬≤', lang: 'Fijian, English, Fiji Hindi' },
            'French Guiana': { iso: 'gf', pop: 0.3, area: '84K km¬≤', lang: 'French' },
            'Gabon': { iso: 'ga', pop: 2.3, area: '268K km¬≤', lang: 'French' },
            'Gambia': { iso: 'gm', pop: 2.4, area: '11K km¬≤', lang: 'English' },
            'Georgia': { iso: 'ge', pop: 3.9, area: '70K km¬≤', lang: 'Georgian' },
            'Ghana': { iso: 'gh', pop: 35.0, area: '240K km¬≤', lang: 'English' },
            'Guatemala': { iso: 'gt', pop: 18.0, area: '109K km¬≤', lang: 'Spanish' },
            'Guinea': { iso: 'gn', pop: 14.0, area: '246K km¬≤', lang: 'French' },
            'Guinea Bissau': { iso: 'gw', pop: 2.1, area: '36K km¬≤', lang: 'Portuguese' },
            'Guyana': { iso: 'gy', pop: 0.7, area: '215K km¬≤', lang: 'English' },
            'Haiti': { iso: 'ht', pop: 11.5, area: '28K km¬≤', lang: 'Haitian Creole, French' },
            'Honduras': { iso: 'hn', pop: 9.6, area: '112K km¬≤', lang: 'Spanish' },
            'Hong Kong': { iso: 'hk', pop: 7.5, area: '1.1K km¬≤', lang: 'Chinese, English' },
            'Ivory Coast': { iso: 'ci', pop: 31.5, area: '322K km¬≤', lang: 'French' },
            'Jamaica': { iso: 'jm', pop: 2.8, area: '11K km¬≤', lang: 'English' },
            'Jordan': { iso: 'jo', pop: 11.5, area: '89K km¬≤', lang: 'Arabic' },
            'Kazakhstan': { iso: 'kz', pop: 20.3, area: '2.7M km¬≤', lang: 'Kazakh, Russian' },
            'Kiribati': { iso: 'ki', pop: 0.1, area: '811 km¬≤', lang: 'English, Gilbertese' },
            'Kosovo': { iso: 'xk', pop: 1.6, area: '11K km¬≤', lang: 'Albanian, Serbian' },
            'Kuwait': { iso: 'kw', pop: 4.8, area: '18K km¬≤', lang: 'Arabic' },
            'Kyrgyzstan': { iso: 'kg', pop: 7.3, area: '200K km¬≤', lang: 'Kyrgyz, Russian' },
            'Laos': { iso: 'la', pop: 8.0, area: '237K km¬≤', lang: 'Lao' },
            'Latvia': { iso: 'lv', pop: 1.8, area: '65K km¬≤', lang: 'Latvian' },
            'Lebanon': { iso: 'lb', pop: 5.4, area: '10K km¬≤', lang: 'Arabic' },
            'Lesotho': { iso: 'ls', pop: 2.2, area: '30K km¬≤', lang: 'Sesotho, English' },
            'Liberia': { iso: 'lr', pop: 5.4, area: '111K km¬≤', lang: 'English' },
            'Libya': { iso: 'ly', pop: 7.4, area: '1.8M km¬≤', lang: 'Arabic' },
            'Lithuania': { iso: 'lt', pop: 2.9, area: '65K km¬≤', lang: 'Lithuanian' },
            'Luxembourg': { iso: 'lu', pop: 0.7, area: '2.6K km¬≤', lang: 'Luxembourgish, French, German' },
            'Macau': { iso: 'mo', pop: 0.7, area: '119 km¬≤', lang: 'Chinese, Portuguese' },
            'Macedonia': { iso: 'mk', pop: 1.8, area: '25K km¬≤', lang: 'Macedonian, Albanian' },
            'Madagascar': { iso: 'mg', pop: 32.0, area: '593K km¬≤', lang: 'Malagasy, French' },
            'Malawi': { iso: 'mw', pop: 22.2, area: '118K km¬≤', lang: 'English' },
            'Maldives': { iso: 'mv', pop: 0.5, area: '298 km¬≤', lang: 'Dhivehi' },
            'Mali': { iso: 'ml', pop: 22.0, area: '1.2M km¬≤', lang: 'French' },
            'Malta': { iso: 'mt', pop: 0.5, area: '316 km¬≤', lang: 'Maltese, English' },
            'Marshall Islands': { iso: 'mh', pop: 0.04, area: '181 km¬≤', lang: 'Marshallese, English' },
            'Mauritania': { iso: 'mr', pop: 4.3, area: '1.0M km¬≤', lang: 'Arabic' },
            'Mauritius': { iso: 'mu', pop: 1.2, area: '2K km¬≤', lang: 'English, French' },
            'Micronesia': { iso: 'fm', pop: 0.1, area: '702 km¬≤', lang: 'English' },
            'Moldova': { iso: 'md', pop: 2.4, area: '34K km¬≤', lang: 'Romanian' },
            'Mongolia': { iso: 'mn', pop: 3.5, area: '1.6M km¬≤', lang: 'Mongolian' },
            'Montenegro': { iso: 'me', pop: 0.6, area: '14K km¬≤', lang: 'Montenegrin' },
            'Morocco': { iso: 'ma', pop: 37.5, area: '447K km¬≤', lang: 'Arabic, Berber' },
            'Mozambique': { iso: 'mz', pop: 34.9, area: '802K km¬≤', lang: 'Portuguese' },
            'Myanmar': { iso: 'mm', pop: 55.8, area: '677K km¬≤', lang: 'Burmese' },
            'Namibia': { iso: 'na', pop: 3.1, area: '826K km¬≤', lang: 'English' },
            'Nauru': { iso: 'nr', pop: 0.01, area: '21 km¬≤', lang: 'Nauruan, English' },
            'Nepal': { iso: 'np', pop: 31.1, area: '148K km¬≤', lang: 'Nepali' },
            'Nicaragua': { iso: 'ni', pop: 6.7, area: '130K km¬≤', lang: 'Spanish' },
            'Niger': { iso: 'ne', pop: 25.0, area: '1.3M km¬≤', lang: 'Hausa, French' },
            'North Korea': { iso: 'kp', pop: 26.3, area: '121K km¬≤', lang: 'Korean' },
            'Oman': { iso: 'om', pop: 5.5, area: '310K km¬≤', lang: 'Arabic' },
            'Palau': { iso: 'pw', pop: 0.02, area: '459 km¬≤', lang: 'Palauan, English' },
            'Panama': { iso: 'pa', pop: 4.3, area: '75K km¬≤', lang: 'Spanish' },
            'Papua New Guinea': { iso: 'pg', pop: 11.8, area: '463K km¬≤', lang: 'English, Tok Pisin, Hiri Motu' },
            'Paraguay': { iso: 'py', pop: 6.4, area: '407K km¬≤', lang: 'Spanish, Guarani' },
            'Puerto Rico': { iso: 'pr', pop: 3.2, area: '14K km¬≤', lang: 'Spanish, English' },
            'Qatar': { iso: 'qa', pop: 3.2, area: '12K km¬≤', lang: 'Arabic' },
            'Rwanda': { iso: 'rw', pop: 13.6, area: '27K km¬≤', lang: 'Kinyarwanda, English, French, Swahili' },
            'Samoa': { iso: 'ws', pop: 0.2, area: '2.8K km¬≤', lang: 'Samoan, English' },
            'Sao Tome And Principe': { iso: 'st', pop: 0.2, area: '964 km¬≤', lang: 'Portuguese' },
            'Senegal': { iso: 'sn', pop: 18.9, area: '197K km¬≤', lang: 'French' },
            'Serbia': { iso: 'rs', pop: 6.6, area: '88K km¬≤', lang: 'Serbian' },
            'Seychelles': { iso: 'sc', pop: 0.1, area: '457 km¬≤', lang: 'Seychellois Creole, English, French' },
            'Sierra Leone': { iso: 'sl', pop: 8.5, area: '73K km¬≤', lang: 'English' },
            'Slovakia': { iso: 'sk', pop: 5.4, area: '49K km¬≤', lang: 'Slovak' },
            'Slovenia': { iso: 'si', pop: 2.1, area: '20K km¬≤', lang: 'Slovene' },
            'Solomon Islands': { iso: 'sb', pop: 0.7, area: '29K km¬≤', lang: 'English' },
            'Somalia': { iso: 'so', pop: 18.1, area: '638K km¬≤', lang: 'Somali, Arabic' },
            'Sri Lanka': { iso: 'lk', pop: 21.8, area: '67K km¬≤', lang: 'Sinhala, Tamil' },
            'Sudan': { iso: 'sd', pop: 50.0, area: '1.9M km¬≤', lang: 'Arabic, English' },
            'Suriname': { iso: 'sr', pop: 0.6, area: '166K km¬≤', lang: 'Dutch' },
            'Swaziland': { iso: 'sz', pop: 1.2, area: '17K km¬≤', lang: 'Swazi, English' },
            'Syria': { iso: 'sy', pop: 25.3, area: '185K km¬≤', lang: 'Arabic' },
            'Taiwan': { iso: 'tw', pop: 23.9, area: '36K km¬≤', lang: 'Mandarin' },
            'Tajikistan': { iso: 'tj', pop: 10.7, area: '143K km¬≤', lang: 'Tajik, Russian' },
            'Tanzania': { iso: 'tz', pop: 67.5, area: '947K km¬≤', lang: 'Swahili, English' },
            'Timor Leste': { iso: 'tl', pop: 1.3, area: '15K km¬≤', lang: 'Portuguese, Tetum' },
            'Togo': { iso: 'tg', pop: 8.6, area: '57K km¬≤', lang: 'French' },
            'Tonga': { iso: 'to', pop: 0.1, area: '748 km¬≤', lang: 'Tongan, English' },
            'Trinidad And Tobago': { iso: 'tt', pop: 1.5, area: '5.1K km¬≤', lang: 'English' },
            'Tunisia': { iso: 'tn', pop: 12.1, area: '164K km¬≤', lang: 'Arabic' },
            'Turkmenistan': { iso: 'tm', pop: 7.1, area: '491K km¬≤', lang: 'Turkmen' },
            'Tuvalu': { iso: 'tv', pop: 0.01, area: '25 km¬≤', lang: 'Tuvaluan, English' },
            'Uganda': { iso: 'ug', pop: 49.3, area: '241K km¬≤', lang: 'English, Swahili' },
            'United Arab Emirates': { iso: 'ae', pop: 11.0, area: '84K km¬≤', lang: 'Arabic' },
            'Uruguay': { iso: 'uy', pop: 3.5, area: '176K km¬≤', lang: 'Spanish' },
            'Uzbekistan': { iso: 'uz', pop: 37.6, area: '449K km¬≤', lang: 'Uzbek' },
            'Vanuatu': { iso: 'vu', pop: 0.3, area: '12K km¬≤', lang: 'Bislama, English, French' },
            'Yemen': { iso: 'ye', pop: 32.7, area: '456K km¬≤', lang: 'Arabic' },
            'Zambia': { iso: 'zm', pop: 20.2, area: '753K km¬≤', lang: 'English' },
            'Zimbabwe': { iso: 'zw', pop: 16.6, area: '391K km¬≤', lang: 'English, Shona' }
        };

        // Legacy ISO mapping for backward compatibility
        const countryToISO = {
            'United States': 'us', 'Canada': 'ca', 'Mexico': 'mx', 'Brazil': 'br', 'Argentina': 'ar',
            'Chile': 'cl', 'Peru': 'pe', 'Colombia': 'co', 'Venezuela': 've', 'Ecuador': 'ec',
            'United Kingdom': 'gb', 'France': 'fr', 'Germany': 'de', 'Italy': 'it', 'Spain': 'es',
            'Portugal': 'pt', 'Netherlands': 'nl', 'Belgium': 'be', 'Switzerland': 'ch', 'Austria': 'at',
            'Poland': 'pl', 'Czech Republic': 'cz', 'Hungary': 'hu', 'Romania': 'ro', 'Bulgaria': 'bg',
            'Greece': 'gr', 'Turkey': 'tr', 'Ukraine': 'ua', 'Russia': 'ru', 'Belarus': 'by',
            'China': 'cn', 'Japan': 'jp', 'South Korea': 'kr', 'North Korea': 'kp', 'India': 'in',
            'Pakistan': 'pk', 'Bangladesh': 'bd', 'Indonesia': 'id', 'Thailand': 'th', 'Vietnam': 'vn',
            'Philippines': 'ph', 'Malaysia': 'my', 'Singapore': 'sg', 'Myanmar': 'mm', 'Cambodia': 'kh',
            'Australia': 'au', 'New Zealand': 'nz', 'Papua New Guinea': 'pg', 'Fiji': 'fj',
            'Egypt': 'eg', 'South Africa': 'za', 'Nigeria': 'ng', 'Kenya': 'ke', 'Ethiopia': 'et',
            'Morocco': 'ma', 'Algeria': 'dz', 'Tunisia': 'tn', 'Libya': 'ly', 'Sudan': 'sd',
            'Saudi Arabia': 'sa', 'Iran': 'ir', 'Iraq': 'iq', 'Israel': 'il', 'Jordan': 'jo',
            'Lebanon': 'lb', 'Syria': 'sy', 'Yemen': 'ye', 'Oman': 'om', 'Kuwait': 'kw',
            'United Arab Emirates': 'ae', 'Qatar': 'qa', 'Bahrain': 'bh',
            'Norway': 'no', 'Sweden': 'se', 'Finland': 'fi', 'Denmark': 'dk', 'Iceland': 'is',
            'Ireland': 'ie', 'Latvia': 'lv', 'Lithuania': 'lt', 'Estonia': 'ee',
            'Slovakia': 'sk', 'Slovenia': 'si', 'Croatia': 'hr', 'Serbia': 'rs', 'Bosnia And Herzegovina': 'ba',
            'Montenegro': 'me', 'Albania': 'al', 'Macedonia': 'mk', 'Kosovo': 'xk',
            'Afghanistan': 'af', 'Kazakhstan': 'kz', 'Uzbekistan': 'uz', 'Turkmenistan': 'tm',
            'Kyrgyzstan': 'kg', 'Tajikistan': 'tj', 'Mongolia': 'mn', 'Nepal': 'np', 'Bhutan': 'bt',
            'Sri Lanka': 'lk', 'Laos': 'la', 'Taiwan': 'tw', 'Hong Kong': 'hk', 'Macau': 'mo',
            'Angola': 'ao', 'Mozambique': 'mz', 'Tanzania': 'tz', 'Uganda': 'ug', 'Rwanda': 'rw',
            'Burundi': 'bi', 'Zimbabwe': 'zw', 'Zambia': 'zm', 'Malawi': 'mw', 'Botswana': 'bw',
            'Namibia': 'na', 'Ghana': 'gh', 'Ivory Coast': 'ci', 'Senegal': 'sn', 'Mali': 'ml',
            'Niger': 'ne', 'Chad': 'td', 'Somalia': 'so', 'Congo': 'cg', 'Gabon': 'ga',
            'Cameroon': 'cm', 'Madagascar': 'mg', 'Mauritania': 'mr', 'Benin': 'bj', 'Togo': 'tg',
            'Uruguay': 'uy', 'Paraguay': 'py', 'Bolivia': 'bo', 'Guyana': 'gy', 'Suriname': 'sr',
            'French Guiana': 'gf', 'Belize': 'bz', 'Guatemala': 'gt', 'Honduras': 'hn', 'Nicaragua': 'ni',
            'Costa Rica': 'cr', 'Panama': 'pa', 'Cuba': 'cu', 'Jamaica': 'jm', 'Haiti': 'ht',
            'Dominican Republic': 'do', 'Puerto Rico': 'pr', 'Trinidad And Tobago': 'tt', 'Barbados': 'bb',
            'Grenada': 'gd', 'Saint Lucia': 'lc', 'Saint Vincent And The Grenadines': 'vc',
            'Antigua And Barbuda': 'ag', 'Dominica': 'dm', 'Saint Kitts And Nevis': 'kn',
            'Luxembourg': 'lu', 'Malta': 'mt', 'Cyprus': 'cy', 'Moldova': 'md', 'Armenia': 'am',
            'Andorra': 'ad', 'San Marino': 'sm', 'Monaco': 'mc', 'Vatican City': 'va', 'Liechtenstein': 'li',
            'Georgia': 'ge', 'Azerbaijan': 'az', 'Eritrea': 'er', 'Djibouti': 'dj',
            'Central African Republic': 'cf', 'Guinea': 'gn', 'Sierra Leone': 'sl', 'Liberia': 'lr',
            'Burkina Faso': 'bf', 'Lesotho': 'ls', 'Swaziland': 'sz', 'Mauritius': 'mu',
            'Seychelles': 'sc', 'Comoros': 'km', 'Cape Verde': 'cv', 'Sao Tome And Principe': 'st',
            'Equatorial Guinea': 'gq', 'Gambia': 'gm', 'Guinea Bissau': 'gw', 'Dem Rep Of Congo': 'cd',
            'Timor Leste': 'tl', 'Brunei': 'bn', 'Maldives': 'mv', 'Solomon Islands': 'sb',
            'Vanuatu': 'vu', 'Samoa': 'ws', 'Kiribati': 'ki', 'Tonga': 'to', 'Micronesia': 'fm',
            'Palau': 'pw', 'Marshall Islands': 'mh', 'Nauru': 'nr', 'Tuvalu': 'tv'
        };

        // Hide SEO content when start button is clicked
        function hideSeoContent() {
            if (!seoContentHidden) {
                seoContentHidden = true;
                const seoContent = elements.get('seo-content');
                if (seoContent) {
                    addClass(seoContent, 'hidden');
                    // Remove after animation completes
                    setTimeout(() => {
                        hide(seoContent);
                    }, 500);
                }
            }
        }

        // Add click event listener to start button (will be available after loading completes)
        // Using event delegation to ensure button is available
        document.addEventListener('click', function(event) {
            if (event.target && event.target.id === 'start-button') {
                hideSeoContent();
            }
        });

        // Initialize the scene
        function init() {
            // ===== PHASE 7: Initialize Flag Renderer =====
            flagRenderer = new FlagRenderer(elements.get('flag-container'), elements);
            flagRenderer.init();

            // ===== PHASE 5: Initialize Core Managers =====

            // 1. Initialize SceneManager
            sceneManager = new SceneManager(elements.get('container'));
            sceneManager.init();

            // Get references for backwards compatibility
            scene = sceneManager.getScene();
            camera = sceneManager.getCamera();
            renderer = sceneManager.getRenderer();
            initialCameraDistance = sceneManager.getInitialCameraDistance();

            // 2. Initialize GlobeManager
            globeManager = new GlobeManager(scene);
            globeManager.init();

            // Get globe reference
            globe = globeManager.getGlobe();
            baseSphere = globeManager.getBaseSphere();

            // 3. Initialize CameraController
            cameraController = new CameraController(camera, renderer, scene);
            cameraController.setupControls();

            // Get controls reference
            controls = cameraController.getControls();

            // 4. Load world data and create labels
            globeManager.loadGlobe(
                // Progress callback
                (percent, message, animated) => {
                    sceneManager.updateLoadingProgress(percent, message, animated, (id) => elements.get(id));
                },
                // Complete callback
                (loadedCountries) => {
                    // Globe loaded successfully
                    countries = loadedCountries;

                    // Get centroids for backwards compatibility with existing quiz/search code
                    countryCentroids = globeManager.getCentroids();

                    // Initialize LabelManager
                    labelManager = new LabelManager(scene, camera, globeManager);
                    labelManager.createLabels(LARGE_COUNTRIES, SMALL_COUNTRIES);

                    // Get labels reference
                    countryLabels = labelManager.getLabels();
                    labelDefaults = labelManager.labelDefaults;

                    // ===== PHASE 6: Initialize Quiz System =====

                    // Initialize QuizManager
                    quizManager = new QuizManager({
                        globeManager: globeManager,
                        cameraController: cameraController,
                        elements: elements
                    });

                    // Initialize quiz modes
                    nameFlagQuiz = new NameFlagQuiz({
                        globeManager: globeManager,
                        cameraController: cameraController,
                        elements: elements,
                        rotateGlobeToCountry: rotateGlobeToCountry,
                        showQuizCelebration: showQuizCelebration,
                        clearQuizTimers: clearQuizTimers,
                        calculateGreatCircleDistance: calculateGreatCircleDistance
                    });

                    identifyFlagQuiz = new IdentifyFlagQuiz({
                        globeManager: globeManager,
                        elements: elements,
                        showQuizCelebration: showQuizCelebration,
                        clearQuizTimers: clearQuizTimers,
                        countryToISO: countryToISO,
                        animateFlagWave: animateFlagWave
                    });

                    clickQuiz = new ClickQuiz({
                        globeManager: globeManager,
                        cameraController: cameraController,
                        elements: elements,
                        showQuizCelebration: showQuizCelebration,
                        clearQuizTimers: clearQuizTimers
                    });

                    // Register quiz modes with QuizManager
                    quizManager.registerMode('name-flag', nameFlagQuiz);
                    quizManager.registerMode('identify-flag', identifyFlagQuiz);
                    quizManager.registerMode('click-country', clickQuiz);

                    // ===== PHASE 9: Initialize Search System =====
                    searchManager = new SearchManager({
                        elements: elements,
                        globeManager: globeManager,
                        flagRenderer: flagRenderer,
                        countryData: countryData,
                        countryToISO: countryToISO,
                        rotateGlobeToCountry: rotateGlobeToCountry,
                        resetIdleTimer: resetIdleTimer
                    });
                    searchManager.init();

                    // ===== PHASE 10: Initialize Label Editor =====
                    labelEditor = new LabelEditor({
                        elements: elements,
                        labelManager: labelManager,
                        scene: scene,
                        camera: camera,
                        controls: controls,
                        raycaster: raycaster,
                        mouse: mouse,
                        updateLabelVisibility: updateLabelVisibility
                    });
                    labelEditor.init();
                    labelEditor.setDefaults(labelDefaults);

                    // Load saved configurations
                    sceneManager.updateLoadingProgress(95, 'Loading configuration...', true, (id) => elements.get(id));
                    labelEditor.loadConfig();
                    loadColorConfig();

                    // Complete loading
                    sceneManager.updateLoadingProgress(100, 'Complete!', true, (id) => elements.get(id));
                    setTimeout(() => hideLoading(), 400);
                },
                // Error callback
                (error) => {
                    console.error('Failed to load globe:', error);
                    hideLoading();
                }
            );

            // Add event listeners
            setupEventListeners();

            // Register render callbacks
            sceneManager.onRender(() => {
                // Update controls
                cameraController.update();

                // Update flag animations
                if (flagRenderer && flagRenderer.isShowing()) {
                    flagRenderer.update();
                }
                // Update identify flag quiz animation
                if (identifyFlagQuiz && identifyFlagQuiz.isActive()) {
                    identifyFlagQuiz.updateAnimation();
                    const renderer = identifyFlagQuiz.getRenderer();
                    const scene = identifyFlagQuiz.getScene();
                    const camera = identifyFlagQuiz.getCamera();
                    if (renderer && scene && camera) {
                        renderer.render(scene, camera);
                    }
                }

                // Update label visibility
                if (labelManager) {
                    labelManager.updateVisibility();
                }

                // Update UI widgets
                updateZoomWidget();
                updateSearchVisibilityOnMobile();
                updateZoomOutButtonVisibility();
            });

            // Sync state with initial variable values
            syncStateWithVariables();

            // Debug: Verify state is working
            console.log('State manager initialized');
            console.log('Quiz state:', state.get('quiz'));
            console.log('Scene camera:', state.get('scene.camera'));

            // Test reactive subscription
            state.subscribe('quiz.score', (newValue, oldValue) => {
                console.log(`Quiz score changed: ${oldValue} -> ${newValue}`);
            });

            // Start animation loop
            sceneManager.start();
        }

        function setupControls() {
            // Create OrbitControls
            controls = new THREE.OrbitControls(camera, renderer.domElement);

            // Enable damping for smooth movement
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Keep earth centered - no panning
            controls.enablePan = false;

            // Set zoom limits (distance from center)
            controls.minDistance = 1.13;  // Closest zoom (optimal close view)
            controls.maxDistance = 10;   // Farthest zoom

            // No restrictions on vertical rotation - user can tilt freely
            // (Polar angle limits removed to allow full sphere rotation)

            // Enable rotation
            controls.enableRotate = true;
            controls.rotateSpeed = 0.5;

            // Auto-rotate disabled initially, will enable after 1 minute of inactivity
            controls.autoRotate = false;
            controls.autoRotateSpeed = 1.0; // 2x rotation speed

            // Set target to center of scene (earth's center)
            controls.target.set(0, 0, 0);
            controls.update();

            // Start idle timer to enable auto-rotation after initial delay
            // TEMPORARILY DISABLED
            // idleTimeout = setTimeout(() => {
            //     resumeAutoRotation();
            // }, IDLE_DELAY);
        }

        // Stop auto-rotation and start idle timer
        function stopAutoRotation() {
            autoRotateEnabled = false;
            controls.autoRotate = false;

            // Clear any existing idle timeout
            if (idleTimeout) {
                clearTimeout(idleTimeout);
            }

            // Start idle timer - resume rotation after idle period
            // TEMPORARILY DISABLED
            // idleTimeout = setTimeout(() => {
            //     resumeAutoRotation();
            // }, IDLE_DELAY);
        }

        // Resume auto-rotation (only if not in quiz mode)
        function resumeAutoRotation() {
            if (!state.get('quiz.active')) {
                autoRotateEnabled = true;
                controls.autoRotate = true;
                // No tilt animation - maintain current camera angle

                // Clear the search selection if searchManager exists
                if (searchManager) {
                    searchManager.clear();
                }

                // Reset all countries to normal state
                countries.forEach(country => {
                    country.material.vertexColors = true;
                    country.material.color.setHex(0xffffff);
                    country.material.needsUpdate = true;
                });

                // Remove small country indicator
                removeSmallCountryIndicator();

                // Hide the flag container
                if (flagRenderer) flagRenderer.hide();
            }
        }

        // Reset idle timer on user interaction
        function resetIdleTimer() {
            lastInteractionTime = Date.now();

            // Only stop rotation if it's currently enabled
            if (autoRotateEnabled) {
                stopAutoRotation();
            }
        }

        function setupLights() {
            // Ambient light - provides overall base illumination
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            // Directional light behind camera (will be updated in animate loop)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(0, 0, 10); // Behind camera
            scene.add(directionalLight);

            // Additional point lights for better coverage
            const pointLight1 = new THREE.PointLight(0xffffff, 0.5);
            pointLight1.position.set(5, 5, 5);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xffffff, 0.5);
            pointLight2.position.set(-5, -5, 5);
            scene.add(pointLight2);

            // Store reference for updating position with camera
            scene.userData.cameraLight = directionalLight;
        }

        // Helper function to update loading progress
        let currentProgress = 0;
        let progressAnimationFrame = null;

        function updateLoadingProgress(percent, message = null, animated = false) {
            const progressFill = elements.get('loading-progress-fill');
            const progressText = elements.get('loading-progress-text');
            const loadingDiv = elements.get('loading');

            if (animated) {
                // Cancel any ongoing animation
                if (progressAnimationFrame) {
                    cancelAnimationFrame(progressAnimationFrame);
                }

                const startProgress = currentProgress;
                const targetProgress = percent;
                const duration = 600; // 600ms for smooth animation
                const startTime = Date.now();

                function animate() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // Ease out cubic for smooth deceleration
                    const easeProgress = 1 - Math.pow(1 - progress, 3);
                    const newProgress = startProgress + (targetProgress - startProgress) * easeProgress;

                    currentProgress = newProgress;

                    if (progressFill) {
                        progressFill.style.width = newProgress + '%';
                    }
                    if (progressText && message) {
                        setText(progressText, message);
                    }

                    if (progress < 1) {
                        progressAnimationFrame = requestAnimationFrame(animate);
                    } else {
                        progressAnimationFrame = null;
                    }
                }

                if (message && progressText) {
                    setText(progressText, message);
                }

                animate();
            } else {
                // Instant update (for download progress)
                currentProgress = percent;

                if (progressFill) {
                    progressFill.style.width = percent + '%';
                }
                if (progressText) {
                    const displayMessage = message || `Loading... ${percent}%`;
                    setText(progressText, displayMessage);
                }
                if (loadingDiv && message) {
                    setText(loadingDiv, message);
                }
            }
        }

        async function loadWorldData() {
            try {
                console.log('Loading world globe...');

                // Create DRACOLoader for decompressing the mesh
                const dracoLoader = new THREE.DRACOLoader();
                dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
                dracoLoader.setDecoderConfig({ type: 'js' });

                // Create GLTFLoader and attach DRACOLoader
                const loader = new THREE.GLTFLoader();
                loader.setDRACOLoader(dracoLoader);

                // Load the pre-built globe GLB file
                loader.load(
                    'assets/world.glb',
                    async function (gltf) {
                        console.log('GLB loaded successfully');
                        updateLoadingProgress(70, 'Processing countries...', true);

                        // Add all meshes from the GLB to the globe
                        gltf.scene.traverse((child) => {
                            if (child.isMesh) {
                                // Store reference for raycasting and interaction
                                child.userData.isCountry = true;

                                // Get the vertex color from the geometry (if available)
                                const hasVertexColors = child.geometry.attributes.color !== undefined;

                                // Set material to use vertex colors with Phong material for smooth lighting
                                if (hasVertexColors) {
                                    child.material = new THREE.MeshPhongMaterial({
                                        vertexColors: true,
                                        transparent: false,
                                        side: THREE.FrontSide,
                                        flatShading: false,
                                        shininess: 30
                                    });
                                } else {
                                    child.material = new THREE.MeshPhongMaterial({
                                        color: 0x4FC3F7,
                                        transparent: false,
                                        side: THREE.FrontSide,
                                        flatShading: false,
                                        shininess: 30
                                    });
                                }

                                // Extract country name from mesh name
                                // Remove the trailing number (e.g., "_0", "_1") and convert to title case
                                const countryName = child.name.replace(/_\d+$/, ''); // Remove trailing _number
                                const formattedName = countryName
                                    .replace(/_/g, ' ') // Replace underscores with spaces
                                    .split(' ')
                                    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                                    .join(' ');
                                child.userData.name = formattedName;

                                countries.push(child);
                            }
                        });

                        await new Promise(resolve => setTimeout(resolve, 300));
                        updateLoadingProgress(78, 'Building globe...', true);

                        // Add the entire scene to the globe
                        globe.add(gltf.scene);

                        console.log(`Loaded ${countries.length} country meshes`);

                        await new Promise(resolve => setTimeout(resolve, 300));
                        updateLoadingProgress(85, 'Calculating positions...', true);

                        // Build country centroids cache for quiz
                        buildCountryCentroidsCache();

                        await new Promise(resolve => setTimeout(resolve, 300));
                        updateLoadingProgress(90, 'Creating labels...', true);

                        // Create country labels
                        createCountryLabels();

                        await new Promise(resolve => setTimeout(resolve, 300));
                        updateLoadingProgress(95, 'Loading configuration...', true);

                        // Load saved color configuration if available
                        loadColorConfig();

                        // Create country borders
                        // createCountryBorders(); // Disabled for performance

                        await new Promise(resolve => setTimeout(resolve, 300));
                        updateLoadingProgress(100, 'Complete!', true);

                        await new Promise(resolve => setTimeout(resolve, 400));
                        hideLoading();
                    },
                    function (xhr) {
                        // Progress callback - scale download to 0-70% of total progress
                        const downloadPercent = (xhr.loaded / xhr.total * 100).toFixed(0);
                        const scaledPercent = Math.floor(downloadPercent * 0.7);
                        console.log(`Downloading: ${downloadPercent}% (scaled: ${scaledPercent}%)`);
                        updateLoadingProgress(scaledPercent, `Downloading... ${downloadPercent}%`);
                    },
                    function (error) {
                        console.error('Error loading GLB:', error);
                        hideLoading();
                    }
                );

            } catch (error) {
                console.error('Error loading world data:', error);
                hideLoading();
            }
        }

        // Helper function for latitude/longitude lines
        function latLngToVector3(lat, lng, radius = 1, height = 0) {
            const phi = (90 - lat) * Math.PI / 180;
            const theta = (lng + 180) * Math.PI / 180;

            const r = radius + height;
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.cos(phi);
            const z = r * Math.sin(phi) * Math.sin(theta);

            return new THREE.Vector3(x, y, z);
        }

        function addLatLongLines() {
            const radius = 1.001; // Slightly larger than globe to prevent z-fighting
            const lineColor = 0x444444;
            const lineMaterial = new THREE.LineBasicMaterial({
                color: lineColor,
                opacity: 0.3,
                transparent: true
            });

            // Add latitude lines (parallels)
            // Every 15 degrees: -75, -60, -45, -30, -15, 0, 15, 30, 45, 60, 75
            for (let lat = -75; lat <= 75; lat += 15) {
                const points = [];
                for (let lng = -180; lng <= 180; lng += 5) {
                    const point = latLngToVector3(lat, lng, radius);
                    points.push(point);
                }
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, lineMaterial);
                globe.add(line);
            }

            // Add longitude lines (meridians)
            // Every 15 degrees
            for (let lng = -180; lng < 180; lng += 15) {
                const points = [];
                for (let lat = -90; lat <= 90; lat += 5) {
                    const point = latLngToVector3(lat, lng, radius);
                    points.push(point);
                }
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, lineMaterial);
                globe.add(line);
            }

            // Add equator with different color for emphasis
            const equatorMaterial = new THREE.LineBasicMaterial({
                color: 0x666666,
                opacity: 0.5,
                transparent: true
            });
            const equatorPoints = [];
            for (let lng = -180; lng <= 180; lng += 2) {
                const point = latLngToVector3(0, lng, radius);
                equatorPoints.push(point);
            }
            const equatorGeometry = new THREE.BufferGeometry().setFromPoints(equatorPoints);
            const equator = new THREE.Line(equatorGeometry, equatorMaterial);
            globe.add(equator);

            // Add prime meridian with different color
            const primeMeridianMaterial = new THREE.LineBasicMaterial({
                color: 0x666666,
                opacity: 0.5,
                transparent: true
            });
            const primeMeridianPoints = [];
            for (let lat = -90; lat <= 90; lat += 2) {
                const point = latLngToVector3(lat, 0, radius);
                primeMeridianPoints.push(point);
            }
            const primeMeridianGeometry = new THREE.BufferGeometry().setFromPoints(primeMeridianPoints);
            const primeMeridian = new THREE.Line(primeMeridianGeometry, primeMeridianMaterial);
            globe.add(primeMeridian);

            // Add polar axis lines extending from north and south poles
            const axisLineMaterial = new THREE.LineBasicMaterial({
                color: 0x333333,
                opacity: 0.2,
                transparent: true
            });

            // North pole axis (extending upward)
            const northAxisPoints = [
                new THREE.Vector3(0, 1, 0),      // North pole surface
                new THREE.Vector3(0, 2.5, 0)     // Extends 1.5 units above globe
            ];
            const northAxisGeometry = new THREE.BufferGeometry().setFromPoints(northAxisPoints);
            const northAxis = new THREE.Line(northAxisGeometry, axisLineMaterial);
            globe.add(northAxis);

            // South pole axis (extending downward)
            const southAxisPoints = [
                new THREE.Vector3(0, -1, 0),     // South pole surface
                new THREE.Vector3(0, -2.5, 0)    // Extends 1.5 units below globe
            ];
            const southAxisGeometry = new THREE.BufferGeometry().setFromPoints(southAxisPoints);
            const southAxis = new THREE.Line(southAxisGeometry, axisLineMaterial);
            globe.add(southAxis);
        }

        function setupEventListeners() {
            // Pointer events (works with mouse, touch, and pen)
            renderer.domElement.addEventListener('pointerdown', onPointerDown);
            renderer.domElement.addEventListener('pointerup', onPointerUp);
            renderer.domElement.addEventListener('pointermove', onPointerMove);

            // Wheel/zoom event (to track user interaction)
            renderer.domElement.addEventListener('wheel', resetIdleTimer);

            // Window resize
            window.addEventListener('resize', onWindowResize);

            // Search input handled by SearchManager.init()

            // Quiz buttons
            elements.get('quiz-start-btn').addEventListener('click', showQuizModeSelector);
            elements.get('quiz-next-btn').addEventListener('click', () => {
                // Cancel auto-advance timer if user clicks manually
                if (nameFlagQuiz && nameFlagQuiz.isActive() && nameFlagQuiz.autoAdvanceTimer) {
                    clearTimeout(nameFlagQuiz.autoAdvanceTimer);
                    nameFlagQuiz.autoAdvanceTimer = null;
                }
                if (identifyFlagQuiz && identifyFlagQuiz.isActive() && identifyFlagQuiz.autoAdvanceTimer) {
                    clearTimeout(identifyFlagQuiz.autoAdvanceTimer);
                    identifyFlagQuiz.autoAdvanceTimer = null;
                }

                // Call appropriate next function based on current quiz mode
                if (identifyFlagQuiz && identifyFlagQuiz.isActive()) {
                    identifyFlagQuiz.nextQuestion();
                } else if (nameFlagQuiz && nameFlagQuiz.isActive()) {
                    nameFlagQuiz.nextQuestion();
                }
            });
            elements.get('take-quiz-btn').addEventListener('click', showQuizModeSelector);

            // Zoom out button
            elements.get('zoom-out-btn').addEventListener('click', zoomOutToDefault);

            // Quiz mode selector buttons
            elements.get('name-flag-quiz-btn').addEventListener('click', () => {
                hideQuizModeSelector();
                nameFlagQuiz.start();
            });
            elements.get('identify-flag-quiz-btn').addEventListener('click', () => {
                hideQuizModeSelector();
                identifyFlagQuiz.start();
            });
            elements.get('find-country-quiz-btn').addEventListener('click', () => {
                hideQuizModeSelector();
                clickQuiz.start();
            });
            elements.get('quiz-mode-close').addEventListener('click', hideQuizModeSelector);
            elements.get('quiz-mode-overlay').addEventListener('click', hideQuizModeSelector);

            // Quiz cancel buttons
            elements.get('quiz-cancel-btn').addEventListener('click', cancelQuiz);
            elements.get('click-quiz-cancel-btn').addEventListener('click', cancelQuiz);

            // Click quiz buttons
            elements.get('click-quiz-close-btn').addEventListener('click', closeClickQuizResults);
            elements.get('click-quiz-results-overlay').addEventListener('click', closeClickQuizResults);

            // Sphere radius controls
            elements.get('sphere-radius-up').addEventListener('click', increaseSphereRadius);
            elements.get('sphere-radius-down').addEventListener('click', decreaseSphereRadius);
            elements.get('sphere-toggle').addEventListener('change', toggleSphere);

            // Edit mode keyboard shortcuts
            window.addEventListener('keydown', onKeyDown);

            // Label editor event listeners handled by labelEditor.init()

            // Color edit mode UI buttons
            elements.get('edit-colors-btn').addEventListener('click', toggleColorEditMode);
            elements.get('save-colors-btn').addEventListener('click', saveColorConfig);
        }

        // Keyboard event handler for edit mode
        function onKeyDown(event) {
            // Don't interfere with typing in input fields
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
                return;
            }

            if (event.key === 'e' || event.key === 'E') {
                if (labelEditor) {
                    labelEditor.toggle();
                }
            } else if (event.key === 's' || event.key === 'S') {
                if (labelEditor && labelEditor.isActive()) {
                    labelEditor.saveConfig();
                }
            }
        }

        // Zoom out to default view
        function zoomOutToDefault() {
            // Remove small country indicator when zooming out
            removeSmallCountryIndicator();

            const targetDistance = initialCameraDistance; // Return to initial camera distance
            const currentPos = camera.position.clone();
            const currentDistance = currentPos.length();

            // Normalize direction
            const direction = currentPos.normalize();

            // Calculate target position
            const targetPos = direction.multiplyScalar(targetDistance);

            // Animate zoom out
            const duration = 1000; // ms
            const startTime = Date.now();
            const startDist = currentDistance;

            function animateZoom() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // Ease out cubic
                const easeProgress = 1 - Math.pow(1 - progress, 3);

                // Interpolate distance
                const newDistance = startDist + (targetDistance - startDist) * easeProgress;

                // Update camera position
                const newPos = currentPos.clone().normalize().multiplyScalar(newDistance);
                camera.position.copy(newPos);
                camera.lookAt(0, 0, 0);
                controls.update();

                if (progress < 1) {
                    requestAnimationFrame(animateZoom);
                }
            }

            animateZoom();
        }


        // Toggle color edit mode
        function toggleColorEditMode() {
            colorEditMode = !colorEditMode;

            const editBtn = elements.get('edit-colors-btn');
            const saveBtn = elements.get('save-colors-btn');

            if (colorEditMode) {
                console.log('Color edit mode ENABLED - Click countries to change colors');

                // Update UI
                addClass(editBtn, 'active');
                setText(editBtn, 'Exit Color Edit');
                show(saveBtn);

                // Disable label edit mode if active
                if (labelEditor && labelEditor.isActive()) {
                    labelEditor.toggle();
                }
            } else {
                console.log('Color edit mode DISABLED');

                // Update UI
                removeClass(editBtn, 'active');
                setText(editBtn, 'Edit Colors');
                hide(saveBtn);
            }
        }

        // Change country color to a random color from palette
        function changeCountryColor(country) {
            if (!country || !colorEditMode) return;

            const countryName = country.userData.name;

            // Pick a random color from the palette
            const randomColor = COLOR_PALETTE[Math.floor(Math.random() * COLOR_PALETTE.length)];

            // Apply color to the country mesh
            const geometry = country.geometry;
            const colorAttribute = geometry.getAttribute('color');

            if (colorAttribute) {
                const colors = colorAttribute.array;
                const vertexCount = colors.length / 3;

                // Set all vertices to the new color
                for (let i = 0; i < vertexCount; i++) {
                    colors[i * 3] = randomColor[0];
                    colors[i * 3 + 1] = randomColor[1];
                    colors[i * 3 + 2] = randomColor[2];
                }

                colorAttribute.needsUpdate = true;
            }

            // Store in config
            colorConfig[countryName] = randomColor;

            console.log(`${countryName} color changed to [${randomColor.join(', ')}]`);

            // Provide haptic feedback if available
            if (navigator.vibrate) {
                navigator.vibrate(30);
            }
        }

        // Save color configuration to JSON file
        function saveColorConfig() {
            const dataStr = JSON.stringify(colorConfig, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);

            const link = document.createElement('a');
            link.href = url;
            link.download = 'country-colors.json';
            link.click();

            URL.revokeObjectURL(url);
            console.log('Color configuration saved! Countries configured:', Object.keys(colorConfig).length);
        }

        let currentSphereRadius = 1.014;

        function toggleSphere(event) {
            if (baseSphere) {
                baseSphere.visible = event.target.checked;
            }
        }

        function increaseSphereRadius() {
            currentSphereRadius += 0.001;
            updateSphereRadius();
        }

        function decreaseSphereRadius() {
            currentSphereRadius -= 0.001;
            updateSphereRadius();
        }

        function updateSphereRadius() {
            // Update the display
            setText(elements.get('sphere-radius-value'), currentSphereRadius.toFixed(3));

            // Remove old sphere
            if (baseSphere) {
                globe.remove(baseSphere);
                baseSphere.geometry.dispose();
                baseSphere.material.dispose();
            }

            // Create new sphere with updated radius
            const sphereGeometry = new THREE.SphereGeometry(currentSphereRadius, 64, 64);
            const sphereMaterial = new THREE.MeshPhongMaterial({
                color: 0x001a33, // Dark blue ocean color
                transparent: false,
                opacity: 1.0,
                side: THREE.BackSide, // Render inside surface to block artifacts
                depthWrite: true,
                shininess: 30, // Moderate reflectivity
                specular: 0x222222 // Subtle highlights
            });
            baseSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            globe.add(baseSphere);

            console.log('Sphere radius updated to:', currentSphereRadius.toFixed(3));
        }

        function onPointerDown(event) {
            // Update mouse coordinates for raycasting
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            mouseDownPos.x = event.clientX;
            mouseDownPos.y = event.clientY;
            isDragging = false;

            // Label editor handles its own pointer down logic
            if (labelEditor) {
                labelEditor.onPointerDown(event, mouseDownPos);
            }
        }

        function onPointerUp(event) {
            // Update mouse coordinates for raycasting (critical for mobile taps)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Label editor handles its own pointer up logic
            if (labelEditor && labelEditor.onPointerUp(event)) {
                return; // Label editor handled the event
            }

            // If this was a drag operation, ignore the pointer release
            if (isDragging) {
                isDragging = false; // Reset for next interaction
                return;
            }

            // Color edit mode: Change country color on click
            if (colorEditMode) {
                raycaster.setFromCamera(mouse, camera);
                const colorIntersects = raycaster.intersectObjects(countries);

                if (colorIntersects.length > 0) {
                    changeCountryColor(colorIntersects[0].object);
                    return; // Don't process normal country selection in color edit mode
                }
            }

            // Not a drag - treat as a click
            // Handle click logic
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(countries);

            if (intersects.length > 0) {
                selectedCountry = intersects[0].object;
                console.log('Selected country:', selectedCountry.userData.name);

                // Handle click quiz answer
                if (clickQuiz && clickQuiz.isActive()) {
                    clickQuiz.handleAnswer(selectedCountry.userData.name);
                    return; // Don't process normal country selection
                }

                // Center on clicked country (if not in quiz mode)
                if (!state.get('quiz.active')) {
                    // Remove old small country indicator before showing new one
                    removeSmallCountryIndicator();

                    // Reset all countries to normal state first
                    countries.forEach(c => {
                        c.material.vertexColors = true;
                        c.material.color.setHex(0xffffff);
                        c.material.needsUpdate = true;
                    });

                    // Highlight only the clicked country
                    selectedCountry.material.vertexColors = false;
                    selectedCountry.material.color.setHex(0xFFFFFF);
                    selectedCountry.material.needsUpdate = true;

                    rotateGlobeToCountry(selectedCountry);
                    // Show the flag for the clicked country
                    if (flagRenderer) {
                        flagRenderer.show(selectedCountry.userData.name, countryData, countryToISO);
                    }
                }
            }
        }

        function onPointerMove(event) {
            // Track user interaction and reset idle timer
            resetIdleTimer();

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Label editor handles its own pointer move logic
            if (labelEditor && labelEditor.onPointerMove(event)) {
                return; // Label editor is handling dragging
            }

            // Detect dragging in real-time (pointer is down and has moved)
            if (event.buttons === 1) { // Primary button is pressed
                const deltaX = Math.abs(event.clientX - mouseDownPos.x);
                const deltaY = Math.abs(event.clientY - mouseDownPos.y);
                if (deltaX > 5 || deltaY > 5) {
                    isDragging = true;
                }
            }

            // Skip hover effects during quiz or while dragging
            if (state.get('quiz.active') || isDragging) {
                return;
            }

            // Raycast for hover effects (cursor change only)
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(countries);

            // Change cursor on hover
            if (intersects.length > 0) {
                document.body.style.cursor = 'pointer';
            } else {
                document.body.style.cursor = 'default';
            }
        }

        function focusOnCountry(country) {
            // Smooth camera movement to focus on country
            const targetPosition = country.position.clone().multiplyScalar(2);
            
            // Simple camera animation (you could use a tween library for smoother animation)
            const startPosition = camera.position.clone();
            const duration = 1000; // ms
            const startTime = Date.now();
            
            function animateCamera() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Ease out cubic
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                camera.position.lerpVectors(startPosition, targetPosition, easeProgress);
                camera.lookAt(0, 0, 0);
                
                if (progress < 1) {
                    requestAnimationFrame(animateCamera);
                }
            }
            
            animateCamera();
        }


        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Recalculate camera distance for new viewport size
            const aspectRatio = window.innerWidth / window.innerHeight;
            const fov = 75 * Math.PI / 180;
            const isMobile = window.innerWidth <= 768;

            let cameraDistance;
            let targetPercentage = isMobile ? 0.85 : 0.65;

            if (aspectRatio >= 1) {
                cameraDistance = (1 / Math.tan(fov / 2)) / targetPercentage;
            } else {
                const horizontalFov = 2 * Math.atan(Math.tan(fov / 2) * aspectRatio);
                cameraDistance = (1 / Math.tan(horizontalFov / 2)) / targetPercentage;
            }

            // Maintain current camera angles but update distance
            const currentDistance = camera.position.length();
            const direction = camera.position.clone().normalize();

            // Update camera position with new distance
            camera.position.copy(direction.multiplyScalar(cameraDistance));

            // Center vertically (remove any previous offset)
            camera.position.y = 0;
            camera.lookAt(0, 0, 0);
            controls.update();
        }

        function hideLoading() {
            hide(elements.get('loading'));

            // Keep fun facts rotating even after loading completes

            // Convert progress bar to start button
            const progressBar = elements.get('loading-progress-bar');
            const startButton = elements.get('start-button');

            if (progressBar) {
                hide(progressBar);
            }

            if (startButton) {
                show(startButton);
            }
        }

        // ============================================
        // QUIZ FUNCTIONALITY
        // ============================================

        // Build cache of country centroids for distance calculations
        function buildCountryCentroidsCache() {
            countryCentroids = [];

            // Get unique country names
            const uniqueCountries = new Map();

            countries.forEach(mesh => {
                const countryName = mesh.userData.name;
                if (!uniqueCountries.has(countryName)) {
                    uniqueCountries.set(countryName, []);
                }
                uniqueCountries.get(countryName).push(mesh);
            });

            // Calculate centroid for each unique country (average of all its meshes' centroids)
            uniqueCountries.forEach((meshes, countryName) => {
                const centroid = new THREE.Vector3(0, 0, 0);
                let totalVertices = 0;

                meshes.forEach(mesh => {
                    const geometry = mesh.geometry;
                    const positions = geometry.attributes.position;

                    for (let i = 0; i < positions.count; i++) {
                        const vertex = new THREE.Vector3(
                            positions.getX(i),
                            positions.getY(i),
                            positions.getZ(i)
                        );
                        // Apply world transform
                        mesh.localToWorld(vertex);
                        centroid.add(vertex);
                        totalVertices++;
                    }
                });

                if (totalVertices > 0) {
                    centroid.divideScalar(totalVertices);
                    // Normalize to sphere surface (in case of small precision errors)
                    centroid.normalize();

                    countryCentroids.push({
                        name: countryName,
                        centroid: centroid,
                        meshRefs: meshes
                    });
                }
            });

            console.log(`Built centroids cache for ${countryCentroids.length} countries`);
        }

        // Create text label using canvas
        function createTextLabel(text) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');

            // Set canvas size
            canvas.width = 512;
            canvas.height = 128;

            // Configure text style
            context.font = '32px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';

            // Draw dark gray text for contrast with ocean
            context.fillStyle = '#686868';
            context.fillText(text, canvas.width / 2, canvas.height / 2);

            // Create texture from canvas
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            return texture;
        }

        // Create labels for all countries
        function createCountryLabels() {
            countryCentroids.forEach(countryData => {
                const countryName = countryData.name;

                // Determine country size category
                let sizeCategory = 'medium'; // Default
                let labelWidth, labelHeight;

                if (LARGE_COUNTRIES.has(countryName)) {
                    sizeCategory = 'large';
                    labelWidth = 0.25;  // Larger labels for large countries
                    labelHeight = 0.065;
                } else if (SMALL_COUNTRIES.has(countryName)) {
                    sizeCategory = 'small';
                    labelWidth = 0.12;  // Smaller labels for small countries
                    labelHeight = 0.032;
                } else {
                    sizeCategory = 'medium';
                    labelWidth = 0.18;  // Medium labels for medium countries
                    labelHeight = 0.048;
                }

                const labelTexture = createTextLabel(countryName);

                // Create material with transparency
                const labelMaterial = new THREE.MeshBasicMaterial({
                    map: labelTexture,
                    transparent: true,
                    opacity: 1.0,
                    side: THREE.DoubleSide,
                    depthTest: false, // Disabled to ensure labels render on top
                    depthWrite: false
                });

                // Create plane geometry with size based on country category
                const labelGeometry = new THREE.PlaneGeometry(labelWidth, labelHeight);
                const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);

                // Position label at country centroid, slightly above surface
                const labelPosition = countryData.centroid.clone().multiplyScalar(1.02);
                labelMesh.position.copy(labelPosition);

                // Orient label to face outward from globe center
                labelMesh.lookAt(countryData.centroid.clone().multiplyScalar(2));

                // Store reference to country name and size category
                labelMesh.userData.countryName = countryName;
                labelMesh.userData.sizeCategory = sizeCategory;

                // Store default position and scale for reset functionality
                labelDefaults[countryName] = {
                    position: labelPosition.clone(),
                    scale: 1.0,
                    width: labelWidth,
                    height: labelHeight
                };

                // Initially hide all labels
                labelMesh.visible = false;

                // Add to globe so it rotates with it
                globe.add(labelMesh);
                countryLabels.push(labelMesh);
            });

            console.log(`Created ${countryLabels.length} country labels`);
        }

        // Create borders for all countries using boundary edge detection
        function createCountryBorders() {
            console.log('Creating country borders...');

            // Iterate through all country meshes
            countries.forEach(countryMesh => {
                const geometry = countryMesh.geometry;
                const positionAttribute = geometry.attributes.position;

                if (!positionAttribute) return;

                // Build edge map to find boundary edges (edges that belong to only one triangle)
                const edgeMap = new Map();
                const indices = geometry.index ? geometry.index.array : null;

                if (!indices) return; // Skip if no index buffer

                // Process all triangles
                for (let i = 0; i < indices.length; i += 3) {
                    const a = indices[i];
                    const b = indices[i + 1];
                    const c = indices[i + 2];

                    // Add the three edges of this triangle
                    addEdge(edgeMap, a, b);
                    addEdge(edgeMap, b, c);
                    addEdge(edgeMap, c, a);
                }

                // Collect boundary edges (edges that appear only once)
                const boundaryEdges = [];
                edgeMap.forEach((count, key) => {
                    if (count === 1) {
                        const [v1, v2] = key.split(',').map(Number);
                        boundaryEdges.push(v1, v2);
                    }
                });

                if (boundaryEdges.length === 0) return;

                // Create geometry from boundary edges
                const borderGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(boundaryEdges.length * 3);

                for (let i = 0; i < boundaryEdges.length; i++) {
                    const vertexIndex = boundaryEdges[i];
                    positions[i * 3] = positionAttribute.getX(vertexIndex);
                    positions[i * 3 + 1] = positionAttribute.getY(vertexIndex);
                    positions[i * 3 + 2] = positionAttribute.getZ(vertexIndex);
                }

                borderGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                // Create line material with dark gray color
                const lineMaterial = new THREE.LineBasicMaterial({
                    color: 0x333333,
                    linewidth: 1
                });

                // Create line segments from boundary edges
                const borderLines = new THREE.LineSegments(borderGeometry, lineMaterial);

                // Copy the country mesh's transform
                borderLines.position.copy(countryMesh.position);
                borderLines.rotation.copy(countryMesh.rotation);
                borderLines.scale.copy(countryMesh.scale);

                // Add to same parent as country mesh
                if (countryMesh.parent) {
                    countryMesh.parent.add(borderLines);
                }

                // Initially hide borders (only show when zoomed in)
                borderLines.visible = false;

                countryBorders.push(borderLines);
            });

            console.log(`Created borders for ${countryBorders.length} countries`);
        }

        // Helper function to add edges to the edge map
        function addEdge(edgeMap, v1, v2) {
            // Create a consistent key regardless of vertex order
            const key = v1 < v2 ? `${v1},${v2}` : `${v2},${v1}`;
            edgeMap.set(key, (edgeMap.get(key) || 0) + 1);
        }

        // Calculate great circle distance between two countries (returns radians)
        // On a unit sphere, the great circle distance is the angle between two vectors
        function calculateGreatCircleDistance(country1, country2) {
            // Use dot product to get cosine of angle
            const dotProduct = country1.centroid.dot(country2.centroid);
            // Clamp to [-1, 1] to handle floating point errors
            const clampedDot = Math.max(-1, Math.min(1, dotProduct));
            // Arc cosine gives us the angle in radians (which is the distance on unit sphere)
            return Math.acos(clampedDot);
        }

        // ===== QUIZ FUNCTIONS MOVED TO js/features/quiz/*.js =====
        // (Removed: NameFlagQuiz, IdentifyFlagQuiz, ClickQuiz implementation functions)
        // All quiz logic now in: name-flag-quiz.js, identify-flag-quiz.js, click-quiz.js

        // Trigger confetti celebration
        function triggerConfetti() {
            // Fire confetti from multiple angles
            const duration = 3000;
            const animationEnd = Date.now() + duration;
            const defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 10001 };

            function randomInRange(min, max) {
                return Math.random() * (max - min) + min;
            }

            const interval = setInterval(function() {
                const timeLeft = animationEnd - Date.now();

                if (timeLeft <= 0) {
                    return clearInterval(interval);
                }

                const particleCount = 50 * (timeLeft / duration);

                // Fire confetti from left
                confetti({
                    ...defaults,
                    particleCount,
                    origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 }
                });

                // Fire confetti from right
                confetti({
                    ...defaults,
                    particleCount,
                    origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 }
                });
            }, 250);
        }

        // Quiz Mode Selector Functions
        function showQuizModeSelector() {
            show(elements.get('quiz-mode-selector'));
        }

        function hideQuizModeSelector() {
            hide(elements.get('quiz-mode-selector'));
        }

        function closeClickQuizResults() {
            hide(elements.get('click-quiz-results'));

            // Show search and quiz button again
            show(elements.get('search-container'));
            show(elements.get('take-quiz-btn'));

            // Resume auto-rotation
            // TEMPORARILY DISABLED
            // resumeAutoRotation();
        }

        function cancelQuiz() {
            // Determine which quiz is active and end it without celebration
            if (nameFlagQuiz && nameFlagQuiz.isActive()) {
                // Clear any timers
                if (nameFlagQuiz.autoAdvanceTimer) {
                    clearTimeout(nameFlagQuiz.autoAdvanceTimer);
                    nameFlagQuiz.autoAdvanceTimer = null;
                }

                // Set active to false without showing celebration
                nameFlagQuiz.active = false;

                // Update state
                state.set('quiz.active', false);
                state.set('quiz.mode', null);

                // Remove quiz-active class
                document.body.classList.remove('quiz-active');

                // Hide quiz elements
                hide(elements.get('quiz-score'));
                hide(elements.get('quiz-question'));
                elements.get('quiz-options').innerHTML = '';
                hide(elements.get('quiz-container'));

                // Reset globe highlighting
                const countries = globeManager.getCountries();
                countries.forEach(country => {
                    country.material.vertexColors = true;
                    country.material.color.setHex(0xffffff);
                    country.material.needsUpdate = true;
                });

                // Show search and quiz button
                show(elements.get('search-container'));
                show(elements.get('take-quiz-btn'));

                // Reset quiz UI
                hide(elements.get('quiz-cancel-btn'));
                elements.get('quiz-next-btn').style.visibility = 'hidden';
                show(elements.get('quiz-start-btn'));
                elements.get('quiz-start-btn').textContent = 'Start Quiz';

            } else if (identifyFlagQuiz && identifyFlagQuiz.isActive()) {
                // Clear any timers
                if (identifyFlagQuiz.autoAdvanceTimer) {
                    clearTimeout(identifyFlagQuiz.autoAdvanceTimer);
                    identifyFlagQuiz.autoAdvanceTimer = null;
                }

                // Set active to false without showing celebration
                identifyFlagQuiz.active = false;

                // Update state
                state.set('quiz.active', false);
                state.set('quiz.mode', null);

                // Remove quiz-active class
                document.body.classList.remove('quiz-active');
                document.body.classList.remove('flag-quiz-active');

                // Hide quiz elements
                hide(elements.get('quiz-score'));
                hide(elements.get('quiz-question'));
                hide(elements.get('quiz-flag-display'));
                elements.get('quiz-options').innerHTML = '';
                hide(elements.get('quiz-container'));

                // Show search and quiz button
                show(elements.get('search-container'));
                show(elements.get('take-quiz-btn'));

                // Reset quiz UI
                hide(elements.get('quiz-cancel-btn'));
                elements.get('quiz-next-btn').style.visibility = 'hidden';
                show(elements.get('quiz-start-btn'));
                elements.get('quiz-start-btn').textContent = 'Start Quiz';

            } else if (clickQuiz && clickQuiz.isActive()) {
                // Clear timer
                if (clickQuiz.timerInterval) {
                    clearInterval(clickQuiz.timerInterval);
                    clickQuiz.timerInterval = null;
                }

                // Set active to false
                clickQuiz.active = false;

                // Update state
                state.set('quiz.active', false);
                state.set('quiz.mode', null);

                // Hide click quiz UI
                hide(elements.get('click-quiz-container'));
                hide(elements.get('click-quiz-timer-bar-container'));

                // Show search and quiz button
                show(elements.get('search-container'));
                show(elements.get('take-quiz-btn'));
            }
        }

        // ===== FLAG RENDERER FUNCTIONS MOVED TO js/features/flag-renderer.js =====
        // (Removed: initFlagRenderer, createWavingFlag, updateFlagAnimation, showWavingFlag, hideWavingFlag)

        // ===== SEARCH FUNCTIONS MOVED TO js/features/search.js =====
        // (Removed: onSearchInput, onSearchKeyDown, updateSearchSelection, selectCountryFromSearch, focusOnCountryByName)

        // Create/update white circle indicator for small countries
        function updateSmallCountryIndicator(country) {
            // Remove old indicator if it exists
            if (smallCountryIndicator) {
                globe.remove(smallCountryIndicator);
                smallCountryIndicator.geometry.dispose();
                smallCountryIndicator.material.dispose();
                smallCountryIndicator = null;
            }

            // Only show indicator for small countries
            const countryName = country.userData.name;
            if (!SMALL_COUNTRIES.has(countryName)) {
                return;
            }

            // Get the country's centroid position
            const geometry = country.geometry;
            const positions = geometry.attributes.position;
            let centerX = 0, centerY = 0, centerZ = 0;
            const vertexCount = positions.count;

            for (let i = 0; i < vertexCount; i++) {
                centerX += positions.getX(i);
                centerY += positions.getY(i);
                centerZ += positions.getZ(i);
            }

            centerX /= vertexCount;
            centerY /= vertexCount;
            centerZ /= vertexCount;

            // Apply country's world matrix
            const worldPos = new THREE.Vector3(centerX, centerY, centerZ);
            country.localToWorld(worldPos);

            // Normalize and scale slightly above surface
            const direction = worldPos.clone().normalize();
            const indicatorPos = direction.multiplyScalar(1.025);

            // Create circle geometry (ring)
            // Radius reduced by 30% (0.03 -> 0.021), thickness reduced by 50% (0.005 -> 0.0025)
            const circleGeometry = new THREE.RingGeometry(0.0185, 0.021, 32);
            const circleMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9
            });

            smallCountryIndicator = new THREE.Mesh(circleGeometry, circleMaterial);

            // Position the circle
            smallCountryIndicator.position.copy(indicatorPos);

            // Orient the circle to face outward from globe center
            smallCountryIndicator.lookAt(0, 0, 0);
            smallCountryIndicator.rotateX(Math.PI);

            // Add to globe
            globe.add(smallCountryIndicator);
        }

        // Remove small country indicator
        function removeSmallCountryIndicator() {
            if (smallCountryIndicator) {
                globe.remove(smallCountryIndicator);
                smallCountryIndicator.geometry.dispose();
                smallCountryIndicator.material.dispose();
                smallCountryIndicator = null;
            }
        }

        // Rotate globe to center a country
        function rotateGlobeToCountry(country, isQuizMode = false) {
            // Get the country's position (centroid of all vertices)
            const geometry = country.geometry;
            const positions = geometry.attributes.position;

            let centerX = 0, centerY = 0, centerZ = 0;
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;
            const vertexCount = positions.count;

            for (let i = 0; i < vertexCount; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                const z = positions.getZ(i);

                centerX += x;
                centerY += y;
                centerZ += z;

                // Track bounding box
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
                minZ = Math.min(minZ, z);
                maxZ = Math.max(maxZ, z);
            }

            centerX /= vertexCount;
            centerY /= vertexCount;
            centerZ /= vertexCount;

            // Calculate bounding box size (approximate land area)
            const bbox = new THREE.Vector3(maxX - minX, maxY - minY, maxZ - minZ);
            const bboxSize = bbox.length(); // Diagonal length of bounding box

            // Apply country's world matrix to get actual position
            const worldPos = new THREE.Vector3(centerX, centerY, centerZ);
            country.localToWorld(worldPos);

            // Normalize to get direction
            worldPos.normalize();

            // Calculate the spherical angles to this position
            let phi = Math.acos(worldPos.y); // Polar angle
            const theta = Math.atan2(worldPos.z, worldPos.x); // Azimuthal angle

            // Adjust phi to position camera lower during quiz mode on mobile only
            // This prevents the quiz container from obscuring the highlighted country
            const isMobile = window.innerWidth <= 768;
            if (isQuizMode && isMobile) {
                phi = phi + 0.4; // Move camera down by ~23 degrees
            }

            // Calculate target camera distance
            let targetDistance;

            if (isQuizMode) {
                // Quiz mode: Use fixed distances to keep zoomed out
                if (bboxSize < 0.15) {
                    targetDistance = 2.0;
                } else if (bboxSize < 0.25) {
                    targetDistance = 2.5;
                } else if (bboxSize < 0.4) {
                    targetDistance = 3.0;
                } else {
                    targetDistance = Math.max(camera.position.length(), 3.5);
                }
            } else {
                // Normal mode: Use fixed zoom levels based on country size
                const countryName = country.userData.name;

                // Small countries zoom closer (1.15), all others zoom to 1.55
                // Note: Some small islands belong to larger countries, so they'll zoom to 1.55
                if (SMALL_COUNTRIES.has(countryName)) {
                    targetDistance = 1.15;
                } else {
                    targetDistance = 1.55;
                }
            }

            // Calculate target camera position
            const targetCameraPos = new THREE.Vector3(
                targetDistance * Math.sin(phi) * Math.cos(theta),
                targetDistance * Math.cos(phi),
                targetDistance * Math.sin(phi) * Math.sin(theta)
            );

            // Animate camera to new position
            const startPos = camera.position.clone();
            const startDist = startPos.length();
            const duration = 1000; // ms
            const startTime = Date.now();

            function animateRotation() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // Ease in-out cubic
                const easeProgress = progress < 0.5
                    ? 4 * progress * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 3) / 2;

                // Interpolate position
                const newPos = new THREE.Vector3().lerpVectors(startPos, targetCameraPos, easeProgress);

                // Interpolate distance as well for smooth zoom
                const newDist = startDist + (targetDistance - startDist) * easeProgress;
                newPos.setLength(newDist);

                camera.position.copy(newPos);
                camera.lookAt(0, 0, 0);
                controls.update();

                if (progress < 1) {
                    requestAnimationFrame(animateRotation);
                } else {
                    // Animation complete - show indicator for small countries (except in quiz mode)
                    if (!isQuizMode) {
                        updateSmallCountryIndicator(country);
                    }
                }
            }

            animateRotation();
        }

        // Update label visibility based on camera distance and orientation
        function updateLabelVisibility() {
            // Delegate to LabelManager if available
            if (labelManager) {
                // Hide all labels during quiz mode
                if (quizActive) {
                    countryLabels.forEach(label => {
                        label.visible = false;
                    });
                    return;
                }

                labelManager.updateVisibility();
            }
        }

        // Update border visibility based on camera distance
        function updateBorderVisibility() {
            if (countryBorders.length === 0) return;

            // Calculate camera distance from globe center
            const cameraDistance = camera.position.length();

            // Show borders when zoomed in (zoom range is 1.5-10)
            // Show borders at medium to close zoom levels
            const BORDER_THRESHOLD = 5.0;

            // Show borders when camera is closer than threshold
            const showBorders = cameraDistance < BORDER_THRESHOLD;

            // Update all border visibility
            countryBorders.forEach(border => {
                border.visible = showBorders;
            });
        }

        // Update zoom widget display
        function updateZoomWidget() {
            const MIN_ZOOM = 1.13;
            const MAX_ZOOM = 10;

            // Get current camera distance
            const currentZoom = camera.position.length();

            // Clamp value
            const clampedZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, currentZoom));

            // Calculate percentage (inverted - closer = higher bar)
            const percentage = ((MAX_ZOOM - clampedZoom) / (MAX_ZOOM - MIN_ZOOM)) * 100;

            // Update bar fill height
            const zoomBarFill = elements.get('zoom-bar-fill');
            if (zoomBarFill) {
                zoomBarFill.style.height = percentage + '%';
            }

            // Update text value
            const zoomValue = elements.get('zoom-value');
            if (zoomValue) {
                setText(zoomValue, clampedZoom.toFixed(2));
            }
        }

        // Update search container visibility on mobile based on zoom level
        function updateSearchVisibilityOnMobile() {
            // Only apply on mobile devices
            const isMobile = window.innerWidth <= 768;
            if (!isMobile) return;

            const searchContainer = elements.get('search-container');
            if (!searchContainer) return;

            // Get current camera distance
            const currentZoom = camera.position.length();

            // Hide search when zoomed in (closer than 3.5), show when zoomed out
            if (currentZoom < 3.5) {
                hide(searchContainer);
            } else {
                show(searchContainer);
            }
        }

        // Update zoom out button visibility based on zoom level
        function updateZoomOutButtonVisibility() {
            const zoomOutBtn = elements.get('zoom-out-btn');
            if (!zoomOutBtn) return;

            // Get current camera distance
            const currentZoom = camera.position.length();

            // Show button when zoomed in (closer than 4), hide when zoomed out
            if (currentZoom < 4) {
                show(zoomOutBtn);
            } else {
                hide(zoomOutBtn);
            }
        }

        // Old animate() function removed - now handled by SceneManager.onRender() callbacks
        // See init() function for render loop registration

        // Start the application
        init();
    </script>
</body>
</html>